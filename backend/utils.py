"""
Utility functions for the mass spectrometry prediction API.
"""

import numpy as np
import logging
import traceback
import base64
from rdkit import Chem
from rdkit.Chem.Draw import rdMolDraw2D
from rdkit.Chem import rdMolDescriptors

def setup_logging(level='INFO'):
    """Configure logging for the application."""
    logging.basicConfig(
        level=logging.getLevelName(level),
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    return logging.getLogger()

logger = setup_logging()

def convert_np_to_list(item):
    """Recursively convert numpy arrays to lists for JSON serialization."""
    if isinstance(item, np.ndarray):
        return item.tolist()
    elif isinstance(item, dict):
        return {k: convert_np_to_list(v) for k, v in item.items()}
    elif isinstance(item, list):
        return [convert_np_to_list(v) for v in item]
    else:
        return item

def ensure_numpy_array(data):
    """Ensure data is a numpy array."""
    if isinstance(data, list):
        return np.array(data)
    return data

def handle_error(error, context="", data=None):
    """Unified error handling function."""
    message = f"Error in {context}: {error}"
    logger.error(message)
    
    if data:
        logger.debug(f"Error data context: {data}")
    
    return {
        'error': message,
        'traceback': traceback.format_exc()
    }

def is_valid_smiles(smi):
    """Check if SMILES string is valid."""
    from rdkit import Chem
    
    if not isinstance(smi, str):
        return False
    try:
        mol = Chem.MolFromSmiles(smi)
        return mol is not None
    except Exception as e:
        logger.error(f"Error validating SMILES {smi}: {str(e)}")
        return False

def smiles_to_png_base64(smiles: str, w: int = 400, h: int = 300) -> str:
    """Convert SMILES string to PNG representation of the molecule encoded as base64.
    
    Args:
        smiles: SMILES string of the molecule
        w: Width of the PNG image
        h: Height of the PNG image
        
    Returns:
        Base64-encoded PNG image of the molecule
    """
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        return ""
    
    drawer = rdMolDraw2D.MolDraw2DCairo(w, h)
    opts = drawer.drawOptions()
    opts.clearBackground = False  # transparent alpha channel
    
    rdMolDraw2D.PrepareAndDrawMolecule(drawer, mol)
    drawer.FinishDrawing()
    
    png_bytes = drawer.GetDrawingText()
    return base64.b64encode(png_bytes).decode()

def _safe_filename(smiles: str) -> str:
    """
    Create a Windows / *nix friendly filename from a SMILES string.
    """
    import re
    # Windows / *nix friendly
    return re.sub(r'[^A-Za-z0-9\-_\.]+', '_', smiles)[:120] or "spectrum"

def peaks_to_msp(pred: dict, scale_to: float = 1000.) -> (str, str):
    """
    Build an MSP block from one prediction record.
    Returns (msp_text, filename_without_extension)
    """
    peaks = pred["peaks"]
    if not peaks:
        # build empty shell – rare, but keeps the API consistent
        peaks_block = "Num Peaks: 0\n"
    else:
        max_i = max(p["intensity"] for p in peaks) or 1.0
        factor = scale_to / max_i                # ints are already 0-1
        peaks_block = f"Num Peaks: {len(peaks)}\n"
        for p in peaks:
            mz = f"{p['mz']:.6f}"
            inten = f"{p['intensity'] * factor:.1f}"
            peaks_block += f"{mz}\t{inten}\n"

    header = [
        f"NAME: {pred['smiles']}",
        "PRECURSORMZ: ",
        "PRECURSORTYPE: ",
        f"FORMULA: ",
        "Ontology: ",
        "INCHIKEY: ",
        "INCHI: ",
        f"SMILES: {pred['smiles']}",
        "RETENTIONTIME: ",
        "CCS: ",
        "IONMODE: Positive",
        "INSTRUMENTTYPE: LC-ESI-qTof",
        "INSTRUMENT: simulation",
        "COLLISIONENERGY: ",
        "Comment: Generated by Spectral Simulation API",
    ]
    msp = "\n".join(header) + "\n" + peaks_block
    return msp, _safe_filename(pred["smiles"])

def smiles_to_name(smiles: str) -> str:
    """Return IUPAC name if RDKit can, else empirical formula."""
    mol = Chem.MolFromSmiles(smiles)
    if not mol:
        return ""
    # 1) Try IUPAC (works if RDKit was compiled with NCI resolver)
    try:
        name = Chem.MolToIUPACName(mol)
        if name:
            return name
    except Exception:
        pass
    # 2) Fallback → formula
    return rdMolDescriptors.CalcMolFormula(mol)