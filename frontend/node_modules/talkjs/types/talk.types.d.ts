/**
 * A node in a {@link TextBlock} that renders its children as a clickable {@link https://talkjs.com/docs/Features/Customizations/Action_Buttons_Links/ | action button} which triggers a custom action.
 *
 * @remarks
 * By default, users do not have permission to send messages containing action buttons as they can be used maliciously to trick others into invoking custom actions.
 * For example, a user could send an "accept offer" action button, but disguise it as "view offer".
 *
 * @public
 */
export declare interface ActionButtonNode {
    type: "actionButton";
    /**
     * The name of the custom action to invoke when the button is clicked.
     */
    action: string;
    /**
     * The parameters to pass to the custom action when the button is clicked.
     */
    params: Record<string, string>;
    children: TextNode[];
}

/**
 * @public
 * Provides additional parameters to custom message action or conversation action events.
 */
export declare interface ActionEventParams {
    /**
     * Any number of key/value pairs that will be sent with the action event.
     *
     * Add to action buttons in your theme components with the syntax `data-<key>=<value>`,
     * or to action buttons in messages with the syntax
     * `action?<key>=<value>`.
     *
     * Examples:
     *
     * The following action button theme component will emit a `color` action event
     * when you click it, with a parameter called `choice` that takes the value `red`:
     *
     * `<ActionButton action="color" data-choice="red">Red</ActionButton>`
     *
     * The following action button message markup will emit a `color` message action event
     * when you click it, with a parameter called `choice` that takes the value `blue`:
     *
     * `<actionbutton:color?choice=blue|Blue>`
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported.
     */
    [key: string]: string;
}

/**
 * A node in a {@link TextBlock} that renders its children as a clickable {@link https://talkjs.com/docs/Features/Customizations/Action_Buttons_Links/ | action link} which triggers a custom action.
 *
 * @remarks
 * By default, users do not have permission to send messages containing `ActionLinkNode` as it can be used maliciously to trick others into invoking custom actions.
 * For example, a user could send an "accept offer" action link, but disguise it as a link to a website.
 *
 * @public
 */
export declare interface ActionLinkNode {
    type: "actionLink";
    /**
     * The name of the custom action to invoke when the link is clicked.
     */
    action: string;
    /**
     * The parameters to pass to the custom action when the link is clicked.
     */
    params: Record<string, string>;
    children: TextNode[];
}

declare type Attachment = {
    url: string;
    size: number;
    dimensions?: AttachmentDimensions;
};

declare type AttachmentDimensions = {
    width?: number;
    height?: number;
    duration?: number;
};

/**
 * A FileBlock variant for an audio attachment, with additional audio-specific metadata.
 *
 * @remarks
 * You can identify this variant by checking for `subtype: "audio"`.
 *
 * The same file could be uploaded as either an audio block, or as a {@link VoiceBlock}.
 * The same data will be available either way, but they will be rendered differently in the UI.
 *
 * Includes metadata about the duration of the audio file in seconds, where available.
 *
 * Audio files that you upload with the TalkJS UI will include the duration as long as the sender's browser can preview the file.
 * Audio files that you upload with the REST API or {@link Session.uploadAudio} will include the duration if you specified it when uploading.
 * Audio files attached in a reply to an email notification will not include the duration.
 *
 * @public
 */
export declare interface AudioBlock {
    type: "file";
    subtype: "audio";
    /**
     * An encoded identifier for this file. Use in {@link SendFileBlock} to send this file in another message.
     */
    fileToken: FileToken;
    /**
     * The URL where you can fetch the file
     */
    url: string;
    /**
     * The size of the file in bytes
     */
    size: number;
    /**
     * The name of the audio file, including file extension
     */
    filename: string;
    /**
     * The duration of the audio in seconds, if known
     */
    duration?: number;
}

export declare interface AudioFileMetadata {
    /**
     * The name of the file including extension.
     */
    filename: string;
    /**
     * The duration of the audio file in seconds, if known.
     */
    duration?: number;
}

/**
 * A node in a {@link TextBlock} that renders `text` as a link (HTML `<a>`).
 *
 * @remarks
 * Used when user-typed text is turned into a link automatically.
 *
 * Unlike {@link LinkNode}, users do have permission to send AutoLinkNodes by default, because the `text` and `url` properties must match.
 * Specifically:
 *
 * - If `text` is an email, `url` must contain a `mailto:` link to the same email address
 *
 * - If `text` is a phone number, `url` must contain a `tel:` link to the same phone number
 *
 * - If `text` is a website, the domain name including subdomains must be the same in both `text` and `url`.
 * If `text` includes a protocol (such as `https`), path (/page), query string (?page=true), or url fragment (#title), they must be the same in `url`.
 * If `text` does not specify a protocol, `url` must use either `https` or `http`.
 *
 * This means that the following AutoLink is valid:
 *
 * ```
 * {
 *     type: "autoLink",
 *     text: "talkjs.com"
 *     url: "https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#AutoLinkNode"
 * }
 * ```
 *
 * That link will appear as `talkjs.com` and link you to the specific section of the documentation that explains how AutoLinkNodes work.
 *
 * These rules ensure that the user knows what link they are clicking, and prevents AutoLinkNode being used for phishing.
 * If you try to send a message containing an AutoLink that breaks these rules, the request will be rejected.
 *
 * @public
 */
export declare interface AutoLinkNode {
    type: "autoLink";
    /**
     * The URL to open when a user clicks this node.
     */
    url: string;
    /**
     * The text to display in the link.
     */
    text: string;
}

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `chatbox.onBlur(() => {...})` instead, without an event parameter.
 */
export declare interface BlurEvent {
}

/**
 * Sent by {@link Session.onBrowserPermissionDenied} when the user tried to do
 * an action that require explicit browser permission, but it was denied.
 *
 * @public
 */
export declare interface BrowserPermissionDeniedEvent {
    /**
     * The type of permission that was denied.
     *
     * @remarks
     * Note that more possible values may be added in the future, so make sure your
     * handler can deal with unknown permission types gracefully.
     */
    type: PermissionType;
}

/**
 * Sent by {@link Session.onBrowserPermissionNeeded} when a browser permission
 * dialog is about to be shown to the user.
 *
 * @public
 */
export declare interface BrowserPermissionNeededEvent {
    /**
     * The type of permission requested.
     *
     * @remarks
     * Note that more possible values may be added in the future, so make sure your
     * handler can deal with unknown permission types gracefully.
     */
    type: PermissionType;
    /**
     * Cancel whatever user action caused the permission to be requested.
     *
     * @remarks
     * For example, if a user wants to share their location for the first time so
     * that this event is triggered, then if you call `preventDefault()`, no
     * permission will be requested from the browser, the location sharing will be
     * cancelled, and TalkJS will continue as if the location sharing button had
     * not been clicked at all.
     *
     * This may be useful if you're using this event to show custom UI elements
     * that nudge users towards granting permission, and this UI has a "cancel"
     * button.
     */
    preventDefault(): void;
}

/**
 * A node in a {@link TextBlock} that adds indentation for a bullet-point list around its children (HTML `<ul>`).
 *
 * @remarks
 * Used when users send a bullet-point list by starting lines of their message with `-` or `*`.
 *
 * @public
 */
export declare interface BulletListNode {
    type: "bulletList";
    children: TextNode[];
}

/**
 * A node in a {@link TextBlock} that renders its children with a bullet-point (HTML `<li>`).
 *
 * @remarks
 * Used when users start a line of their message with `-` or `*`.
 *
 * @public
 */
export declare interface BulletPointNode {
    type: "bulletPoint";
    children: TextNode[];
}

/**
 * A messaging UI for just a single conversation
 *
 * @remarks
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Chatbox.select}).
 * Create a Chatbox through {@link Session.createChatbox} and then call
 * {@link Chatbox.mount} to show it.
 * @public
 */
export declare interface Chatbox extends UIBox {
    /**
     * Renders the Chatbox UI inside a DOM element on your page.
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | null): Promise<void>;
    /**
     * Destroys the chatbox and removes it from the DOM
     *
     * @remarks
     * Destroys the chatbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the chatbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Chatbox
 * @public
 */
export declare interface ChatboxOptions {
    /**
     * Controls the text direction (for supporting right-to-left languages such as Arabic and Hebrew). TalkJS tries
     * to determine the appropriate text direction from the parent page, but if that does not work or you want to
     * explicitly control it, you can override it here. Defaults to "rtl".
     */
    dir?: "rtl" | "ltr";
    /**
     * Sets the message input box to the given text.
     * You can use this to suggest a certain initial message to be sent. The user can still edit it before hitting "send".
     *
     * @deprecated We recommend using {@link MessageField.setText} before mounting the chatbox to precisely control when message suggestions are shown.
     */
    messageSuggestion?: string;
    /**
     * Used to control if the Chat Header is displayed in the UI. Defaults to true.
     */
    showChatHeader?: boolean;
    /**
     * Controls what text appears in the chat title, in the header above the messages.
     * Defaults to `"participants"`.
     *
     * (also see {@link ChatboxOptions.chatSubtitleMode} and {@link InboxOptions.feedConversationTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme}, or an older custom theme which does not have a ChatHeader component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    chatTitleMode?: "subject" | "participants";
    /**
     * Controls what text appears in the chat subtitle, right below the chat title.
     * No subtitle is displayed when the conversation has no subject set or when set to `null`.
     * Defaults to `"subject"`.
     *
     * (also see {@link ChatboxOptions.chatTitleMode} and {@link InboxOptions.feedConversationTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme }, or an older custom theme which does not have a ChatHeader component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    chatSubtitleMode?: "subject" | "participants" | null;
    /**
     * TalkJS leverages `iframe`s behind the scenes and therefore not all services that you use in your app will work out of the box.
     * This option adds support for a number of services to help you use them. Let us know if you're missing any.
     */
    thirdparties?: ThirdPartyOptions;
    /**
     * Used to control which messages are shown in the message list, depending on a type, origin
     * or custom message attributes.
     *
     * *Note*: Messages are only filtered in the message list. The inbox UI's conversation feed will always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link UIBox.setMessageFilter}.
     */
    messageFilter?: MessagePredicate;
    /**
     * TalkJS can translate conversations to the current user's locale using Google Translate.
     * This option specifies which conversations should be translated in this UI. You can pass a boolean to enable or turn off
     * translation for all conversations, "auto" to enable translation on conversations where users have different locales,
     * or you can pass an array of {@link ConversationBuilder}s or conversation Ids to be translated.
     * This feature is only available on the Growth plan and above. Make sure you add your Google Translate API key on the "Settings" page of the dashboard.
     */
    translateConversations?: boolean | "auto" | string[] | ConversationBuilder[];
    /**
     * Set this to `true` to show a translation toggle in all conversations.
     * Set this to `"auto"` to show a translation toggle in conversations where there are participants with different locales.
     * This setting defaults to `false`, meaning that no toggles will be shown.
     * In order to use this, you must be on the Growth plan, and set a Google Translate API key on the "Settings" page of the dashboard.
     */
    showTranslationToggle?: boolean | "auto";
    /**
     * Settings that affect the behavior of the message field
     */
    messageField?: MessageFieldOptions;
    /**
     * Overrides the theme used for this chat UI.
     *
     * @remarks
     * This only works with themes created in the Theme Editor. If you don't pass a theme name, we'll first check for a theme set in the user's role, and then fall back to using the default theme.
     *
     * You can either pass the name of the theme you'd like to use, or a {@link ThemeOptions} object, which you can use to pass variables to your theme.
     */
    theme?: string | ThemeOptions;
    /**
     * Enables capturing {@link Chatbox.onKeyup} events.
     *
     * @remarks
     * Note: Setting this to true also disables any non-standard keyboard shortcuts in TalkJS.
     *
     * At the time of writing, the only such shortcut is that when `captureKeyboardEvents` is
     * disabled, TalkJS will auto-focus the message field if the user starts typing but no input field
     * is focused.
     */
    captureKeyboardEvents?: boolean;
    /**
     * Sets metadata for the current session.
     *
     * @remarks
     * - `visible` manually sets the information about the visibility of TalkJS.
     *   This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     *   marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     *   not be marked as read until you set `visible` to true again.
     *
     * - `custom` is an additional parameter to store the custom fields, that you
     *   may want to use in the REST API call.
     */
    presence?: UserPresence;
    /**
     * Allows users to send and receive custom emojis.
     *
     * @remarks
     * This adds a set of custom emoji images to the emoji picker, the emoji
     * autocompleter, and emoji reactions.
     *
     * Every emoji name *must* start and end with a colon, for example `:lol:`.
     *
     * Make sure you always specify a consistent, backward-compatible set of
     * custom emojis. If an existing message contains a custom emoji that is not
     * specified in `customEmojis` here, then the emoji cannot be displayed and
     * the textual name will be displayed instead (including colons).
     *
     * If you want to allow an emoji to be displayed if it's used in existing
     * data, but not let users select it in new messages/reactions, set the
     * `hidden` option to `true` for that emoji.
     *
     * @example
     * ```
     * {
     *   ":lol:": { url: "https://example.com/images/emoji-lol.svg" },
     *   ":roomba-cat:": { url: "https://example.com/images/roomba-cat.gif" },
     *   ":alert:": { url: "https://example.com/images/alert.gif", hidden: true },
     * }
     * ```
     */
    customEmojis?: {
        [name: string]: CustomEmojiDefinition;
    };
}

/** @public
 * @hidden due to being empty
 * @deprecated Use `popup.onClose(() => {...})` instead, without an event parameter
 */
declare interface CloseEvent_2 {
}
export { CloseEvent_2 as CloseEvent }

/**
 * A node in a {@link TextBlock} that renders `text` in an inline code span (HTML `<code>`).
 *
 * @remarks
 * Used when a user types ```text```.
 *
 * @public
 */
export declare interface CodeSpanNode {
    type: "codeSpan";
    text: string;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}.
 *
 * The first element must be the string "any", and the second element a list of SimpleConversationPredicate objects.
 *
 * For example, to match all the conversations to which you have read access,
 * or whose custom "accountId" field has the "my_account" value, use the following:
 * ```js
 * ["any", [{"access": ["==", "Read"]}, {"custom": {"accountId": ["==", "my_account"]}}]]
 * ```
 *
 * See {@link SimpleConversationPredicate} for all available options.
 *
 * @public
 */
export declare type CompoundConversationPredicate = [
"any",
SimpleConversationPredicate[]
];

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}.
 *
 * The first element must be the string "any", and the second element a list of SimpleMessagePredicate objects.
 *
 * For example, to match all the messages that are either of the type SystemMessage,
 * or whose sender has the "admin" role, use the following:
 * ```js
 * ["any", [{"type": ["==", "SystemMessage"]}, {"sender": {"role": ["==", "admin"]}}]]
 * ```
 *
 * See {@link SimpleMessagePredicate} for all available options.
 *
 * @public
 */
export declare type CompoundMessagePredicate = ["any", SimpleMessagePredicate[]];

/**
 * The content of a message is structured as a list of content blocks.
 *
 * @remarks
 * Currently, each message can only have one content block, but this will change in the future.
 * This will not be considered a breaking change, so your code should assume there can be multiple content blocks.
 *
 * These blocks are rendered in order, top-to-bottom.
 *
 * Currently the available Content Block types are:
 *
 * - `type: "text"` ({@link TextBlock})
 *
 * - `type: "file"` ({@link FileBlock})
 *
 * - `type: "location"` ({@link LocationBlock})
 *
 * @public
 */
export declare type ContentBlock = TextBlock | FileBlock | LocationBlock;

/**
 * Encapsulates an active conversation between two parties.
 *
 * @remarks
 * Use this object to send system messages to the conversation or to programmatically select a
 * conversation by passing it to {@link Inbox.select}.
 *
 * Conversation objects are created with the deprecated {@link Session.getOrStartConversation}
 * method.
 *
 *
 * @public
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface Conversation {
    /**
     * The ID of the conversation
     */
    readonly id: string;
    /**
     * @hidden
     * An array of {@link Participant | Participants} in the conversation.
     */
    participants: Array<Participant>;
    /**
     * An optional conversation subject which is displayed in the chat header
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * Optional custom conversation meta data
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    welcomeMessages?: Array<string> | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.

     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
}

/**
 * @public
 * A string that must be `"ReadWrite"`, `"Read"` or `"None"`.
 */
export declare type ConversationAccessLevel = "ReadWrite" | "Read" | "None";

/**
 * @public
 * Emitted from {@link Chatbox.onCustomConversationAction} when a user clicks on a
 * custom action in a conversation within the TalkJS UI
 */
export declare interface ConversationActionEvent {
    action: string;
    params: ActionEventParams;
    /**
     * The value will be `null` if the conversation action is triggered
     * from inside the `ConversationListHeader` component.
     */
    conversation: ConversationData | null;
}

/**
 * The state of a conversation subscription when it is actively listening for changes
 *
 * @public
 */
export declare interface ConversationActiveState {
    type: "active";
    /**
     * The most recently received snapshot for the conversation, or `null` if you are not a participant in the conversation (including when the conversation does not exist).
     */
    latestSnapshot: ConversationSnapshot | null;
}

/**
 * Conversation attributes that can be set using {@link ConversationBuilder.setAttributes}
 * @public
 */
export declare interface ConversationAttributes {
    /**
     * A human-readable subject of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://example.com/booking/18644|home by the sea>!`.
     *  URLs and email addresses are made clickable, and emojis made to work cross-platform.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * The URL of a photo to be used for this conversation in the TalkJS UI in case there are more than 2 participants
     * (TalkJS shows the photo of the other participant in a 1-on-1 conversation)
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * Custom metadata that is stored with the conversation
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [key: string]: string | null;
    } | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessages?: Array<string> | null;
}

/**
 * A Conversation Builder represents a conversation that is about to be created, fetched, or updated.
 * You can use this object to set up or modify a conversation before showing it.
 *
 * @remarks
 * Note: any changes you make here will not be sent to TalkJS immediately.
 * Instead, instantiate a TalkJS UI using methods such as {@link Session.createInbox}.
 *
 * @public
 */
export declare interface ConversationBuilder {
    /**
     * An optional conversation subject which will be displayed in the chat header.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    subject?: string | null;
    /**
     * Allows custom conversation metadata to be stored in the form `{ [name: string]: string }`
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * An optional URL to a photo which will be shown as the photo for the conversation.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * Messages which are sent at the beginning of a chat.
     * In this case the messages will appear as system messages.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessages?: Array<string> | null;
    /**
     * Sets a participant of the conversation.
     *
     * @remarks
     * This method is idempotent and can be called multiple times.
     *
     * @param user - A `User` object that identifies the person who is a participant of the
     * conversation. The user is uniquely identified by their id; all other fields (name, photo etc)
     * are overwritten in the TalkJS database each  time they change.
     * @param settings - An optional setting of participation, can be an initial `access` right or
     * if user should be notified.
     */
    setParticipant(user: User, settings?: Partial<ParticipationSettings>): void;
    /**
     * Used to set certain attributes for a specific conversation
     *
     * @remarks
     * For example:
     *
     * ```
     * conversation.setAttributes({subject: "Booking question"});
     * conversation.setAttributes({custom:
     *   {
     *     sold: "true",
     *     itemId: "720"
     *   }
     * });
     *
     * ```
     *
     */
    setAttributes(attributes: ConversationAttributes): void;
    /**
     * Sends a text message in a given conversation.
     * @param text - The message body that is to be sent.
     */
    sendMessage(text: string, options?: SendMessageOptions): Promise<void>;
    /**
     * Removes the current user from this conversation.
     *
     * @returns A promise that resolves with true upon success (indicating that
     * the user has been removed from this conversation), or false when the user
     * did not have the appropriate permissions, as defined on the "Chat UI" page in the
     * TalkJS dashboard). The promise may reject in case of an unexpected error.
     */
    leave(): Promise<boolean>;
}

/** @public */
export declare interface ConversationData {
    /**
     * The ID of the conversation
     */
    id: string;
    /**
     * Contains custom metadata for the conversation if it was set using {@link ConversationBuilder.custom}.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     * When sending `custom: null` all properties and values will be removed.
     */
    custom: CustomData;
    /**
     * Contains the conversation subject if it was set using {@link ConversationBuilder.subject}.
     */
    subject: string | null;
    /**
     * Contains the URL of a photo was set using {@link ConversationBuilder.subject}.
     */
    photoUrl: string | null;
    /**
     * One or more welcome messages that will display to the user as a SystemMessage
     */
    welcomeMessages: Array<string> | null;
    /**
     * A map of the access rights for the participants in this conversation.
     *
     * This property is not guaranteed to be complete.
     * It always includes the current user, but does not always list other participants.
     *
     * Specifically, `ConversationData` returned from the following functions will only include the current user: `Session.onMessage`, `Session.onDesktopNotificationClicked`, `Session.unreads.onChange`.
     * In all other cases, this field contains every participant in the conversation.
     *
     * Note on guest access:
     * This field indicates a user's access as a participant.
     * Guests always have "ReadWrite" access and are not included in this map
     */
    participants: Record<string, {
        access: "Read" | "ReadWrite";
    }>;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}.
 *
 * The ConversationPredicate can be either of the following:
 *
 * - a single SimpleConversationPredicate object that filters based on all the fields of the predicate
 *
 * - an array that gives you all the conversations that satisfy at least one of the SimpleConversationPredicates
 *
 * See {@link SimpleConversationPredicate} and {@link CompoundConversationPredicate} for all available options.
 *
 * @public
 */
export declare type ConversationPredicate = SimpleConversationPredicate | CompoundConversationPredicate;

/**
 * References the conversation with a given conversation ID, from the perspective of the current user.
 *
 * @remarks
 * Used in all Realtime API operations affecting that conversation, such as fetching or updating conversation attributes.
 * Created via {@link Session.conversation}.
 *
 * @public
 */
export declare interface ConversationRef {
    /**
     * The ID of the referenced conversation.
     *
     * @remarks
     * Immutable: if you want to reference a different conversation, get a new ConversationRef instead.
     */
    readonly id: string;
    /**
     * Get a reference to a participant in this conversation
     *
     * @param user - the user's ID or a reference to the user
     */
    participant(user: string | UserRef): ParticipantRef;
    /**
     * Get a reference to a message in this conversation
     *
     * @param user - the message ID
     */
    message(id: string): MessageRef;
    /**
     * Fetches a snapshot of the conversation.
     *
     * @remarks
     * This contains all of the information related to the conversation and the current user's participation in the conversation.
     *
     * @returns A snapshot of the current user's view of the conversation, or null if the current user is not a participant (including if the conversation doesn't exist).
     */
    get(): Promise<ConversationSnapshot | null>;
    /**
     * Sets properties of this conversation and your participation in it.
     *
     * @remarks
     * The conversation is created if a conversation with this ID doesn't already exist.
     * You are added as a participant if you are not already a participant in the conversation.
     *
     * @returns A promise that resolves when the operation completes.
     * When client-side conversation syncing is disabled, you may only set your `notify` property, when you are already a participant.
     * Everything else requires client-side conversation syncing to be enabled, and will cause the promise to reject.
     */
    set(params: SetConversationParams): Promise<void>;
    /**
     * Creates this conversation if it does not already exist.
     * Adds you as a participant in this conversation, if you are not already a participant.
     *
     * @remarks
     * If the conversation already exists or you are already a participant, this operation is still considered successful and the promise will still resolve.
     *
     * @returns A promise that resolves when the operation completes. The promise rejects if you are not already a participant and client-side conversation syncing is disabled.
     */
    createIfNotExists(params?: CreateConversationParams): Promise<void>;
    /**
     * Marks the conversation as read.
     *
     * @returns A promise that resolves when the operation completes. The promise rejects if you are not a participant in the conversation.
     */
    markAsRead(): Promise<void>;
    /**
     * Marks the conversation as unread.
     *
     * @returns A promise that resolves when the operation completes. The promise rejects if you are not a participant in the conversation.
     */
    markAsUnread(): Promise<void>;
    /**
     * Sends a message in the conversation
     *
     * @returns A promise that resolves with a reference to the newly created message. The promise will reject if you do not have permission to send the message.
     */
    send(params: string | SendTextMessageParams | SendMessageParams): Promise<MessageRef>;
    /**
     * Subscribes to the messages in the conversation.
     *
     * @remarks
     * Initially, you will be subscribed to the 30 most recent messages and any new messages.
     * Call `loadMore` to load additional older messages.
     *
     * Whenever `Subscription.state.type` is "active" and a message is sent, edited, deleted, or you load more messages, `onSnapshot` will fire and `Subscription.state.latestSnapshot` will be updated.
     * `loadedAll` is true when the snapshot contains all the messages in the conversation.
     *
     * The snapshot is null if you are not a participant in the conversation (including when the conversation doesn't exist)
     */
    subscribeMessages(onSnapshot?: (snapshot: MessageSnapshot[] | null, loadedAll: boolean) => void): MessageSubscription;
    /**
     * Subscribes to the conversation.
     *
     * @remarks
     * Whenever `Subscription.state.type` is "active" and something about the conversation changes, `onSnapshot` will fire and `Subscription.state.latestSnapshot` will be updated.
     * This includes changes to nested data. As an extreme example, `onSnapshot` would be called if `snapshot.lastMessage.referencedMessage.sender.name` changes.
     *
     * The snapshot is null if you are not a participant in the conversation (including when the conversation doesn't exist)
     */
    subscribe(onSnapshot?: (snapshot: ConversationSnapshot | null) => void): ConversationSubscription;
}

/** @public
 *
 * This represents the interface of the event triggered from {@link Inbox.onConversationSelected}.
 */
export declare interface ConversationSelectedEvent {
    /**
     * The current TalkJS User
     */
    me: UserSnapshot;
    /**
     * @deprecated When you are the only participant in the conversation, this property includes the current user. Use `participants` and filter out the current user instead.
     *
     * The other participants in the conversation that are not the current user
     */
    others?: Array<UserSnapshot>;
    /**
     * The participants in the conversation, including the current user
     */
    participants?: Array<UserSnapshot>;
    /**
     * The current conversation object
     */
    conversation: ConversationData | null;
}

/**
 * A snapshot of a conversation's attributes at a given moment in time.
 *
 * @remarks
 * Also includes information about the current user's view of that conversation, such as whether or not notifications are enabled.
 *
 * Snapshots are immutable and we try to reuse them when possible. You should only re-render your UI when `oldSnapshot !== newSnapshot`.
 *
 * @public
 */
export declare interface ConversationSnapshot {
    /**
     * The ID of the conversation
     */
    id: string;
    /**
     * Contains the conversation subject if it was set using {@link ConversationBuilder.subject}.
     */
    subject: string | null;
    /**
     * Contains the URL of a photo was set using {@link ConversationBuilder.subject}.
     */
    photoUrl: string | null;
    /**
     * One or more welcome messages that will display to the user as a SystemMessage
     */
    welcomeMessages: string[];
    /**
     * Custom metadata you have set on the conversation
     */
    custom: Record<string, string>;
    /**
     * The date that the conversation was created, as a unix timestamp in milliseconds.
     */
    createdAt: number;
    /**
     * The date that the current user joined the conversation, as a unix timestamp in milliseconds.
     */
    joinedAt: number;
    /**
     * The last message sent in this conversation, or null if no messages have been sent.
     */
    lastMessage: MessageSnapshot | null;
    /**
     * The number of messages in this conversation that the current user hasn't read.
     */
    unreadMessageCount: number;
    /**
     * Timestamp of when the current user read a message
     */
    readUntil: number;
    /**
     * Whether the conversation should be considered unread.
     *
     * @remarks
     * This can be true even when `unreadMessageCount` is zero, if the user has manually marked the conversation as unread.
     */
    isUnread: boolean;
    /**
     * The current user's permission level in this conversation.
     */
    access: "Read" | "ReadWrite";
    /**
     * The current user's notification settings for this conversation.
     *
     * @remarks
     * `false` means no notifications, `true` means notifications for all messages, and `"MentionsOnly"` means that the user will only be notified when they are mentioned with an `@`.
     */
    notify: boolean | "MentionsOnly";
}

/**
 * A subscription to a specific conversation.
 *
 * @remarks
 * Get a ConversationSubscription by calling {@link ConversationRef.subscribe}
 *
 * @public
 */
export declare interface ConversationSubscription {
    /**
     * The current state of the subscription
     *
     * @remarks
     * An object with the following fields:
     *
     * `type` is one of "pending", "active", "unsubscribed", or "error".
     *
     * When `type` is "active", includes `latestSnapshot: ConversationSnapshot | null`, the current state of the conversation.
     * `latestSnapshot` is `null` when you are not a participant or the conversation does not exist.
     *
     * When `type` is "error", includes the `error` field. It is a JS `Error` object explaining what caused the subscription to be terminated.
     */
    state: PendingState | ConversationActiveState | UnsubscribedState | ErrorState;
    /**
     * Resolves when the subscription starts receiving updates from the server.
     */
    connected: Promise<ConversationActiveState>;
    /**
     * Resolves when the subscription permanently stops receiving updates from the server.
     *
     * @remarks
     * This is either because you unsubscribed or because the subscription encountered an unrecoverable error.
     */
    terminated: Promise<UnsubscribedState | ErrorState>;
    /**
     * Unsubscribe from this resource and stop receiving updates.
     *
     * @remarks
     * If the subscription is already in the "unsubscribed" or "error" state, this is a no-op.
     */
    unsubscribe(): void;
}

/**
 * Parameters you can pass to {@link ConversationRef.createIfNotExists}.
 *
 * Properties that are `undefined` will be set to the default.
 *
 * @public
 */
export declare interface CreateConversationParams {
    /**
     * The conversation subject to display in the chat header.
     * Default = no subject, list participant names instead.
     */
    subject?: string;
    /**
     * The URL for the conversation photo to display in the chat header.
     * Default = no photo, show a placeholder image.
     */
    photoUrl?: string;
    /**
     * System messages which are sent at the beginning of a conversation.
     * Default = no messages.
     */
    welcomeMessages?: string[];
    /**
     * Custom metadata you have set on the conversation.
     * This value acts as a patch. Remove specific properties by setting them to `null`.
     * Default = no custom metadata
     */
    custom?: Record<string, string>;
    /**
     * Your access to the conversation.
     * Default = "ReadWrite" access.
     */
    access?: "Read" | "ReadWrite";
    /**
     * Your notification settings.
     * Default = `true`
     */
    notify?: boolean | "MentionsOnly";
}

/**
 * Parameters you can pass to {@link ParticipantRef.createIfNotExists}.
 *
 * @remarks
 * Properties that are `undefined` will be set to the default.
 *
 * @public
 */
export declare interface CreateParticipantParams {
    /**
     * The level of access the participant should have in the conversation.
     * Default = "ReadWrite" access.
     */
    access?: "ReadWrite" | "Read";
    /**
     * When the participant should be notified about new messages in this conversation.
     * Default = `true`
     *
     * @remarks
     * `false` means no notifications, `true` means notifications for all messages, and `"MentionsOnly"` means that the user will only be notified when they are mentioned with an `@`.
     */
    notify?: boolean | "MentionsOnly";
}

/**
 * Parameters you can pass to {@link UserRef.createIfNotExists}.
 *
 * @remarks
 * Properties that are `undefined` will be set to the default.
 *
 * @public
 */
export declare interface CreateUserParams {
    /**
     * The user's name which is displayed on the TalkJS UI
     */
    name: string;
    /**
     * Custom metadata you have set on the user.
     * Default = no custom metadata
     */
    custom?: Record<string, string>;
    /**
     * An {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}
     * Default = the locale selected on the dashboard
     */
    locale?: string;
    /**
     * An optional URL to a photo that is displayed as the user's avatar.
     * Default = no photo
     */
    photoUrl?: string;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     * Default = the `default` role
     */
    role?: string;
    /**
     * The default message a person sees when starting a chat with this user.
     * Default = no welcome message
     */
    welcomeMessage?: string;
    /**
     * A single email address or an array of email addresses associated with the user.
     * Default = no email addresses
     */
    email?: string | string[];
    /**
     * A single phone number or an array of phone numbers associated with the user.
     * Default = no phone numbers
     */
    phone?: string | string[];
    /**
     * An object of push registration tokens to use when notifying this user.
     *
     * Keys in the object have the format `'provider:token_id'`,
     * where `provider` is either `"fcm"` for Android (Firebase Cloud Messaging),
     * or `"apns"` for iOS (Apple Push Notification Service).
     *
     * Default = no push registration tokens
     */
    pushTokens?: Record<string, true>;
}

/**
 * @public
 * Used to store additional metadata on users, conversations and messages
 */
export declare interface CustomData {
    /**
     * Any number of key/value pairs of your choosing to be stored along with the associated resource.
     * You can use custom data for all kinds of purposes, such as customizing a user's email notification text, transmitting contextual user data, or making email login tokens.
     *
     * Both the key and the value must be strings; arbitrarily deeply nested JSON is not supported. Example:
     *
     * ```
     * {"country":"nl", "itemId": "720"}
     * ```
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    [key: string]: string;
}

/**
 * Defines a custom emoji
 *
 * @remarks
 * See {@link ChatboxOptions.customEmojis}
 *
 * @public
 */
export declare interface CustomEmojiDefinition {
    /**
     * Image file URL
     *
     * @remarks
     * Must be a fully-qualified URL of image file, eg an SVG, GIF or PNG. The
     * image must be square (same width and height) and is always scaled down to
     * the size of an emoji.
     */
    url: string;
    /**
     * Hides this emoji from the emoji picker and autocompleter
     *
     * @remarks
     * Hidden emojis can't be sent in new messages, or used in new emoji
     * reactions, but they still display properly in existing messages and
     * reactions. This lets you safely remove previously used custom emoji from
     * the chat UI.
     */
    hidden?: boolean;
}

/**
 * A node in a {@link TextBlock} that is used for {@link https://talkjs.com/docs/Features/Message_Features/Emoji_Reactions/#custom-emojis | custom emoji}.
 *
 * @public
 */
export declare interface CustomEmojiNode {
    type: "customEmoji";
    /**
     * The name of the custom emoji to show.
     */
    text: string;
}

/**
 * @public
 * A string or a two-element array that forms a predicate about a string field in a `custom` field.
 *
 * @remarks
 * Used in {@link MessagePredicate} and {@link ConversationPredicate}.
 * Allows all forms in {@link FieldPredicate} plus the following:
 *
 * - `"exists"`
 *
 * - `"!exists"`
 */
export declare type CustomFieldPredicate = FieldPredicate<string> | "exists" | "!exists";

/**
 * Sent by {@link Session.onDesktopNotificationClicked} when a user clicks on a browser notification.
 *
 * @public
 */
export declare interface DesktopNotificationClickedEvent {
    conversation: ConversationData;
}

/**
 * @public
 * This event is triggered when {@link https://talkjs.com/docs/Features/Notifications/Browser_Notifications | desktop notifications} are toggled.
 */
export declare interface DesktopNotificationToggledEvent {
    /**
     * Boolean indicating if desktop Notifications are enabled or not
     */
    isEnabled: boolean;
}

/**
 * Parameters you can pass to {@link MessageRef.edit}.
 *
 * @remarks
 * Properties that are `undefined` will not be changed.
 * To clear / reset a property to the default, pass `null`.
 *
 * This is the more advanced method for editing a message. It gives you full control over the message content.
 * You can decide exactly how a text message should be formatted, edit an attachment, or even turn a text message into a location.
 *
 * @public
 */
export declare interface EditMessageParams {
    /**
     * Custom metadata you have set on the message.
     * This value acts as a patch. Remove specific properties by setting them to `null`.
     * Default = no custom metadata
     */
    custom?: Record<string, string | null> | null;
    /**
     * The new content for the message.
     *
     * @remarks
     * Any value provided here will overwrite the existing message content.
     *
     * By default users do not have permission to send {@link LinkNode}, {@link ActionLinkNode}, or {@link ActionButtonNode}, as they can be used to trick the recipient.
     */
    content?: [SendContentBlock];
}

/**
 * Parameters you can pass to {@link MessageRef.edit}.
 *
 * @remarks
 * Properties that are `undefined` will not be changed.
 * To clear / reset a property to the default, pass `null`.
 *
 * This is a simpler version of {@link EditMessageParams} that only supports setting the message content to text.
 *
 * @public
 */
export declare interface EditTextMessageParams {
    /**
     * Custom metadata you have set on the message.
     * This value acts as a patch. Remove specific properties by setting them to `null`.
     * Default = no custom metadata
     */
    custom?: Record<string, string | null> | null;
    /**
     * The new text to set in the message body.
     *
     * @remarks
     * This is parsed the same way as the text entered in the message field. For example, `*hi*` will appear as `hi` in bold.
     *
     * See the {@link https://talkjs.com/docs/Features/Message_Features/Formatting/ | message formatting documentation} for more details.
     */
    text?: string;
}

/**
 * @public
 * A machine-readable error code enum.
 *
 * @remarks
 * Supports the following values:
 *
 * - `NOTIFICATIONS_PERMISSION_DENIED`
 *
 * - `NOTIFICATIONS_NOT_SUPPORTED`
 *
 * - `ARGUMENT_INVALID`
 */
export declare enum ErrorCode {
    NOTIFICATIONS_PERMISSION_DENIED = 0,
    NOTIFICATIONS_NOT_SUPPORTED = 1,
    ARGUMENT_INVALID = 2
}

/**
 * The state of a subscription after it encounters an unrecoverable error
 *
 * @public
 */
export declare interface ErrorState {
    type: "error";
    /**
     * The error that caused the subscription to be terminated
     */
    error: Error;
}

/**
 * @public
 * A two-element array that forms a predicate about a field.
 *
 * @remarks
 * Used in {@link MessagePredicate} and {@link ConversationPredicate}.
 * Possible forms:
 *
 * - `["==", "someValue"]`
 *
 * - `["!=", "someValue"]`
 *
 * - `["oneOf", ["someValue", "someOtherValue"]]`
 *
 * - `["!oneOf", ["someValue", "someOtherValue"]]`
 */
export declare type FieldPredicate<T> = ["==" | "!=", T] | ["oneOf" | "!oneOf", T[]];

/**
 * A file attachment received in a message's content.
 *
 * @remarks
 * All `FileBlock` variants contain `url`, `size`, and `fileToken`.
 * Some file blocks have additional metadata, in which case they will have the `subtype` property set.
 *
 * Currently the available FileBlock subtypes are:
 *
 * - No `subtype` set ({@link GenericFileBlock})
 *
 * - `subtype: "video"` ({@link VideoBlock})
 *
 * - `subtype: "image"` ({@link ImageBlock})
 *
 * - `subtype: "audio"` ({@link AudioBlock})
 *
 * - `subtype: "voice"` ({@link VoiceBlock})
 *
 * @public
 */
export declare type FileBlock = VideoBlock | ImageBlock | AudioBlock | VoiceBlock | GenericFileBlock;

/**
 * A token representing a file uploaded to TalkJS.
 *
 * @remarks
 * You cannot create a FileToken yourself. Get a file token by uploading your file to TalkJS with {@link Session.uploadFile}, or one of the subtype-specific variants like {@link Session.uploadImage}.
 *
 * For example:
 *
 * ```
 * // From `<input type="file">`
 * const file: File = fileInputElement.files[0];
 * const myFileToken = await session.uploadFile(file, { filename: file.name });
 * ```
 *
 * Alternatively, take a file token from an existing {@link FileBlock} to re-send an attachment you received, without having to download and re-upload the file.
 *
 * You can also upload files using the {@link https://talkjs.com/docs/Reference/REST_API/Messages/#1-upload-a-file| REST API}.
 *
 * Passed in {@link SendFileBlock} when you send a message containing a file attachment:
 *
 * ```
 * const block: SendFileBlock = {
 *   type: 'file',
 *   fileToken: myFileToken,
 * };
 *
 * const convRef = session.conversation('example_conversation_id');
 * convRef.send({ content: [block] });
 * ```
 *
 * We may change the FileToken format in the future.
 * Do not store old file tokens for future use, as these may stop working.
 *
 * This system ensures that all files must be uploaded to TalkJS before being sent to users, limiting the risk of malware.
 *
 * @public
 */
export declare type FileToken = string & {
    __tag: Record<"TalkJS Encoded File Token", true>;
};

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `chatbox.onFocus(() => {...})` instead, without an event parameter.
 */
declare interface FocusEvent_2 {
}
export { FocusEvent_2 as FocusEvent }

/**
 *  @public
 */
export declare interface FullStoryOptions {
    /**
     * Fullstory hostname
     */
    host?: string;
    /**
     * Fullstory organization ID
     */
    org: string;
}

/**
 * The most basic FileBlock variant, used whenever there is no additional metadata for a file.
 *
 * @remarks
 * Do not try to check for `subtype === undefined` directly, as this will break when we add new FileBlock variants in the future.
 *
 * Instead, treat GenericFileBlock as the default. For example:
 *
 * ```
 * if (block.subtype === "video") {
 *     handleVideoBlock(block);
 * } else if (block.subtype === "image") {
 *     handleImageBlock(block);
 * } else if (block.subtype === "audio") {
 *     handleAudioBlock(block);
 * } else if (block.subtype === "voice") {
 *     handleVoiceBlock(block);
 * } else {
 *     handleGenericFileBlock(block);
 * }
 * ```
 *
 * @public
 */
export declare interface GenericFileBlock {
    type: "file";
    /**
     * Never set for generic file blocks.
     */
    subtype?: undefined;
    /**
     * An encoded identifier for this file. Use in {@link SendFileBlock} to send this file in another message.
     */
    fileToken: FileToken;
    /**
     * The URL where you can fetch the file
     */
    url: string;
    /**
     * The size of the file in bytes
     */
    size: number;
    /**
     * The name of the file, including file extension
     */
    filename: string;
}

export declare interface GenericFileMetadata {
    /**
     * The name of the file including extension.
     */
    filename: string;
}

/**
 * @public
 * @hidden
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface GetOrStartOptionsA {
    /**
     * A human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /**
     * Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /**
     * Photo to be used for this conversation in the TalkJS UI.
     */
    photoUrl?: string;
    welcomeMessages?: string[];
}

/**
 * @public
 * @hidden
 * @deprecated Use {@link Session.getOrCreateConversation} instead
 */
export declare interface GetOrStartOptionsB {
    participants: Array<User>;
    /**
     * A human-readable subject
     * of the conversation. Supports formatted links in a Markdown-style syntax, e.g.
     * `Beautiful <https://yoursite.com/booking/18644|home by the sea>!`.
     * URLs and email addresses are made clickable, and emojis made to work
     * cross-platform.
     */
    subject?: string;
    /**
     * Additional parameter to store the custom fields, that you
     * want to use in the email template. E.g. `custom.specialToken`
     */
    custom?: {
        [name: string]: string;
    };
    /**
     * Photo to be used for this conversation in the TalkJS UI.
     */
    photoUrl?: string;
}

/**
 * HTML Panel
 * HTML panels should only be created through {@link Inbox.createHtmlPanel}, {@link Chatbox.createHtmlPanel} or {@link Popup.createHtmlPanel}.
 * @public
 */
export declare interface HtmlPanel {
    /**
     * Shows the panel if it's hidden.
     */
    show(): void;
    /**
     * Hides the panel if it's visible.
     */
    hide(): void;
    /**
     * Changes the panel height.
     *
     * @remarks
     * If you don't need to change the height after the panel is created, you can pass it as an option to the `createHtmlPanel`.
     */
    setHeight(height: number): void;
    /**
     * Returns `true` if the panel is visible, `false` if it's hidden or destroyed
     */
    isVisible(): boolean;
    /**
     * Destroys the HTML panel
     */
    destroy(): Promise<void>;
    /**
     * The HTML Panel iframe's {@link https://developer.mozilla.org/en-US/docs/Web/API/Window | window} object
     */
    window: Window;
    /**
     * This promise resolves when the "DOMContentLoaded" event fires on the ifram's window.
     */
    DOMContentLoadedPromise: Promise<void>;
    /**
     * This promise resolves when the "load" event fires on the ifram's window.
     */
    windowLoadedPromise: Promise<void>;
}

/** @public */
export declare interface HtmlPanelOptions {
    /**
     * Required. URL you want to load inside the HTML panel.
     * Url can be absolute ("https://www.example.com/register-form.html") or relative ("register-form.html").
     * We recommend using same origin pages to have better control of the page.
     * Learn more about HTML Panels and same origin pages {@link https://talkjs.com/docs/Customizations/HTML_Panels.html | here}.
     */
    url: string;
    /**
     * Optional, defaults to 100 (px).
     */
    height?: number;
    /**
     * Optional, defaults to true. Set false if you don't want the HTML panel to be shown after
     * `createHtmlPanel` is called. You can change the visibility of the HTML panels by
     * calling `.hide()` or `.show()` on the `HtmlPanel` instance returned by `createHtmlPanel`'s promise.
     */
    show?: boolean;
    /**
     * Either a `Conversation` object
     * (as returned from `getOrCreateConversation`) or the `id` field of
     * a conversation (which you may have stored in your database).
     * If given the HTML panel called will only show up for that conversation.
     */
    conversation?: Conversation | ConversationBuilder | string;
}

/**
 * A FileBlock variant for an image attachment, with additional image-specific metadata.
 *
 * @remarks
 * You can identify this variant by checking for `subtype: "image"`.
 *
 * Includes metadata about the height and width of the image in pixels, where available.
 *
 * Images that you upload with the TalkJS UI will include the image dimensions as long as the sender's browser can preview the file.
 * Images that you upload with the REST API or {@link Session.uploadImage} will include the dimensions if you specified them when uploading.
 * Image attached in a reply to an email notification will not include the dimensions.
 *
 * @public
 */
export declare interface ImageBlock {
    type: "file";
    subtype: "image";
    /**
     * An encoded identifier for this file. Use in {@link SendFileBlock} to send this image in another message.
     */
    fileToken: FileToken;
    /**
     * The URL where you can fetch the file.
     */
    url: string;
    /**
     * The size of the file in bytes.
     */
    size: number;
    /**
     * The name of the image file, including file extension.
     */
    filename: string;
    /**
     * The width of the image in pixels, if known.
     */
    width?: number;
    /**
     * The height of the image in pixels, if known.
     */
    height?: number;
}

export declare interface ImageFileMetadata {
    /**
     * The name of the file including extension.
     */
    filename: string;
    /**
     * The width of the image in pixels, if known.
     */
    width?: number;
    /**
     * The height of the image in pixels, if known.
     */
    height?: number;
}

/**
 * The main messaging UI. Chats on the left, messages on the right.
 * Create an Inbox through {@link Session.createInbox} and then call {@link Inbox.mount} to show it.
 * @public
 */
export declare interface Inbox extends UIBox {
    /**
     * The conversation currently shown in the UI.
     *
     * @remarks
     * This field is `null` when the UI does not currently show a conversation (eg
     * because `null` was passed to {@link UIBox.select}, it's an Inbox with only
     * conversation list visible, or the selected conversation could not be
     * found).
     *
     * This field will always be equal to
     * {@link ConversationSelectedEvent.conversation | conversation} in the
     * {@link Inbox.onConversationSelected} event.
     *
     * Also note that because the {@link Inbox.onSelectConversation} event is
     * emitted before the new conversation is actually shown, this field will
     * still reflect the previous conversation at that point.
     */
    readonly currentConversation: ConversationData | null;
    /**
     * Controls which conversations are shown in the conversation feed
     *
     * @remarks
     * Lets you filter conversations in the conversation list, depending on access level, custom
     * conversation attributes or message read status.
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also set the filter in {@link Session.createInbox} using
     * {@link InboxOptions.feedFilter}.
     *
     * @param filter - A predicate object that controls which conversations are shown.
     */
    setFeedFilter(filter: ConversationPredicate): void;
    /**
     * Renders the Inbox UI inside a DOM element on your page
     *
     * @remarks
     * The container element specified by `container` must either be a DOM Element (as returned by e.g.
     * `document.getElementById`) or a JQuery object with a single element.
     */
    mount(container: HTMLElement | null): Promise<void>;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSelectConversation} instead.
     */
    on(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onConversationSelected} instead.
     */
    on(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onDesktopNotificationToggled} instead.
     */
    on(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.translationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Inbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSelectConversation} instead.
     */
    off(eventType: "selectConversation", handler: (event: SelectConversationEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onConversationSelected} instead.
     */
    off(eventType: "conversationSelected", handler: (event: ConversationSelectedEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onDesktopNotificationToggled} instead.
     */
    off(eventType: "desktopNotificationToggled", handler: (event: DesktopNotificationToggledEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Inbox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Inbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Triggers when a user clicks a conversation in the conversation list.
     *
     * @remarks
     * This event is triggered *before* a conversation is selected.
     * You can prevent the conversation from being actually selected by calling `event.preventDefault()`.
     */
    onSelectConversation(handler: (event: SelectConversationEvent) => void): Subscription;
    /**
     * Triggers after a conversation is selected
     *
     * @remarks
     * This event is emitted in 4 situations:
     *
     * 1. When the Inbox loads;
     *
     * 2. When the user clicks on a conversation in the feed;
     *
     * 3. When something in your code calls {@link Inbox.select}
     *
     * 4. When the Inbox is shown in mobile view, and the user clicks the `< Inbox` button.
     *
     * Note that the event's `conversation` field will be `null` when the inbox loads (and the user
     * has no conversations), when calling {@link Inbox.select} with `null` to deselect any
     * conversation, and in case 4 above.
     */
    onConversationSelected(handler: (event: ConversationSelectedEvent) => void): Subscription;
    /**
     * Triggers when the user toggles the "Desktop Notifications" toggle in the inbox conversation list header.
     */
    onDesktopNotificationToggled(handler: (event: DesktopNotificationToggledEvent) => void): Subscription;
    /**
     * Destroys the inbox and removes it from the DOM
     *
     * @remarks
     * Destroys the inbox, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the inbox container from the DOM.
     */
    destroy(): void;
}

/**
 * @alias UIBox Inbox
 * @public
 */
export declare interface InboxOptions extends ChatboxOptions {
    /**
     * Makes the inbox start up with the given Conversation. Can be passed a value of the type ConversationBuilder (returned by getOrCreateConversation) or the string value of the conversation id. Conversation can be deselected on startup by passing a null value. Passing undefined means that the last conversation (or "no chats yet page") will be displayed.
     *
     * @deprecated Please use {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Inbox/#Inbox__select | Inbox.select} instead.
     */
    selected?: Conversation | ConversationBuilder | string | null;
    /**
     * Controls if the feed header containing the toggle to enable desktop notifications is shown.
     * Defaults to true.
     */
    showFeedHeader?: boolean;
    /**
     * Controls how a chat is displayed in the feed of chats.
     *
     * Note: when set to `"subject"` but a conversation has no subject set, then
     * TalkJS falls back to `"participants"`.
     *
     * When not set, defaults to `"auto"`, which means that in group conversations
     * that have a subject set, the subject is displayed and otherwise the participants.
     *
     * (also see {@link ChatboxOptions.chatSubtitleMode} and {@link ChatboxOptions.chatTitleMode})
     *
     * @deprecated This field only has effect if you use a {@link https://talkjs.com/docs/Features/Themes/Legacy_Themes_(limited_CSS)/ | Legacy Theme }, or an older custom theme which does not have a ConversationListItem component. If you do not, edit the ChatHeader component in the theme editor instead.
     */
    feedConversationTitleMode?: "participants" | "subject" | "auto";
    /**
     * Controls whether the user navigating between conversation should count
     * as steps in the browser history. Defaults to true, which means that if the user
     * clicks the browser's back button, they go back to the previous conversation
     * (if any).
     */
    useBrowserHistory?: boolean;
    /**
     * Used to control which conversations are shown in the conversation feed, depending on access
     * level, custom conversation attributes or message read status.
     *
     * The feedFilter can be either of the following:
     * - a single ConversationPredicate object that filters based on all the fields
     * of the predicate
     * - an array that gives you all the conversations that satisfy at least one
     * of the ConversationPredicates
     *
     * When filtering conversations with an array, the first element must be the string
     * "any", and the second element a list of ConversationPredicate objects.
     *
     * For example, to match all the conversations to which you have read access,
     * or whose custom "accountId" field has the "my_account" value, use the following:
     * ```js
     * ["any", [{"access": ["==", "Read"]}, {"custom": {"accountId": ["==", "my_account"]}}]]
     * ```
     *
     * See {@link ConversationPredicate} for all available options.
     *
     * You can also modify the filter on the fly using {@link Inbox.setFeedFilter}.
     */
    feedFilter?: ConversationPredicate;
    /**
     * Whether to show a "Back" button at the top of the chat screen on mobile devices.
     */
    showMobileBackButton?: boolean;
}

/**
 * @public
 * @hidden
 * Anything that can be JSON-serialised.
 */
export declare type JsonSerializable = string | number | boolean | null | JsonSerializableObject | JsonSerializableArray;

/**
 * @public
 * @hidden
 */
export declare interface JsonSerializableArray extends Array<JsonSerializable> {
}

/**
 * @public
 * @hidden
 */
export declare interface JsonSerializableObject {
    [key: string]: JsonSerializable;
}

/**
 * @public
 * Emitted through {@link Chatbox.onKeyup} when the user presses a key.
 * All fields except `isInputFocused` precisely match the corresponding fields in the browser's
 * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
 */
declare interface KeyEvent {
    /**
     * True if the event was triggered while an element was focused that can handle keyboard events.
     */
    isInputFocused: boolean;
    altKey: boolean;
    code: string;
    ctrlKey: boolean;
    key: string;
    location: number;
    metaKey: boolean;
    shiftKey: boolean;
    repeat: boolean;
}
export { KeyEvent }
export { KeyEvent as KeyupEvent }

/**
 * @public
 * Triggered when the user clicks a "Leave conversation" action in the chat UI.
 *
 * @see {@link Chatbox.onLeaveConversation}
 */
export declare interface LeaveConversationEvent {
    /**
     * The conversation that the user intends to leave
     */
    conversation: ConversationData;
    /**
     * Call this to prevent the conversation from being left, ie to cancel the
     * user action.
     *
     * @remarks
     * Doing this will turn the "Leave conversation" action into a no-op, so you
     * might want to display some sort of error message to the user so they
     * understand why their click didn't do anything.
     *
     * You can only call `preventDefault` from inside the `onLeaveConversation`
     * event handler or a function immediately invoked from it. Calling
     * `preventDefault` later, or after some promise resolved, has no effect.
     */
    preventDefault(): void;
}

/**
 * A node in a {@link TextBlock} that renders its children as a clickable link (HTML `<a>`).
 *
 * @remarks
 * By default, users do not have permission to send messages containing `LinkNode` as it can be used to maliciously hide the true destination of a link.
 *
 * @public
 */
export declare interface LinkNode {
    type: "link";
    /**
     * The URL to open when the node is clicked.
     */
    url: string;
    children: TextNode[];
}

/**
 * A block showing a location in the world, typically because a user shared their location in the chat.
 *
 * @remarks
 * In the TalkJS UI, location blocks are rendered as a link to Google Maps, with the map pin showing at the specified coordinate.
 * A thumbnail shows the surrounding area on the map.
 *
 * @public
 */
export declare interface LocationBlock {
    type: "location";
    /**
     * The north-south coordinate of the location.
     *
     * @remarks
     * Usually listed first in a pair of coordinates.
     *
     * Must be a number between -90 and 90
     */
    latitude: number;
    /**
     * The east-west coordinate of the location.
     *
     * @remarks
     * Usually listed second in a pair of coordinates.
     *
     * Must be a number between -180 and 180
     */
    longitude: number;
}

/**
 * @public
 * Triggered when the user clicks a "Mark as unread" action in the chat UI.
 *
 * @see {@link Chatbox.onMarkConversationAsUnread}
 */
export declare interface MarkConversationAsUnreadEvent {
    /**
     * The conversation that the user intends to mark as unread
     */
    conversation: ConversationData;
    /**
     * Call this to prevent the conversation from being marked as unread, ie to
     * cancel the user action.
     *
     * @remarks
     * Doing this will turn the "Mark as unread" action into a no-op, so you might
     * want to display some sort of error message to the user so they understand
     * why their click didn't do anything.
     *
     * You can only call `preventDefault` from inside the
     * `onMarkConversationAsUnread` event handler or a function immediately
     * invoked from it. Calling `preventDefault` later, or after some promise
     * resolved, has no effect.
     */
    preventDefault(): void;
}

/**
 * A node in a {@link TextBlock} that renders its children with a specific style.
 *
 * @public
 */
export declare interface MarkupNode {
    /**
     * The kind of formatting to apply when rendering the children
     *
     * - `type: "bold"` is used when users type `*text*` and is rendered with HTML `<strong>`
     *
     * - `type: "italic"` is used when users type `_text_` and is rendered with HTML `<em>`
     *
     * - `type: "strikethrough"` is used when users type `~text~` and is rendered with HTML `<s>`
     */
    type: "bold" | "italic" | "strikethrough";
    children: TextNode[];
}

/**
 * A node in a {@link TextBlock} that is used when a user is {@link https://talkjs.com/docs/Features/Message_Features/Mentions/ | mentioned}.
 *
 * @remarks
 * Used when a user types `@name` and selects the user they want to mention.
 *
 * @public
 */
export declare interface MentionNode {
    type: "mention";
    /**
     * The ID of the user who is mentioned.
     */
    id: string;
    /**
     * The name of the user who is mentioned.
     */
    text: string;
}

/**
 * @public
 * A TalkJS message, used as part of {@link Session.onMessage}
 */
export declare interface Message {
    /**
     * The message's ID.
     */
    id: string;
    /**
     * Contains the {@link ConversationData} that the message belongs to.
     */
    conversation: ConversationData;
    /**
     * 'true' if the message was sent by the current user.
     */
    isByMe: boolean;
    /**
     * The senderID (userID) for the person that sent the message
     */
    senderId: string | null;
    /**
     * The {@link User} that sent the message
     */
    sender: UserSnapshot | null;
    /**
     * Contains the message's content
     */
    body: string;
    /**
     * Specifies if if the message is media (file), text or a shared location
     */
    type: "media" | "text" | "location";
    /**
     * UNIX timestamp specifying when the message was sent (UTC, in milliseconds)
     */
    timestamp: number;
    /**
     * 'true' if the message has been read, 'false' has not been seen yet
     */
    read: boolean;
    /**
     * Determines how this message was sent: respectively, Via a web browser (or mobile Webview), via the REST API, via reply-to-email, or using the import API.
     */
    origin: string;
    /**
     * Custom metadata that is stored with the conversation
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom: CustomData;
    /**
     * Only given if the message's `type` equals `"media"`. An object with the URL and filesize (in bytes) of the given file. Attachment dimensions (in px) are sometimes available for media file attachments, used to set the size of the thumbnail before loading, to prevent content shift when loading media on slower connections.
     */
    attachment: Attachment | null;
    /**
     * Only given if the message's `type` equals `"location"`. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location: [number, number] | null;
}

/**
 * @public
 * Emitted from {@link Chatbox.onCustomMessageAction} when a user clicks on a
 * custom action, as defined on the "Chat UI" page of the dashboard.
 */
export declare interface MessageActionEvent {
    action: string;
    params: ActionEventParams;
    message: Message;
}

/**
 * The state of a messages subscription when it is actively listening for changes
 *
 * @public
 */
export declare interface MessageActiveState {
    type: "active";
    /**
     * The most recently received snapshot for the user, or `null` if the user does not exist yet.
     */
    latestSnapshot: MessageSnapshot[] | null;
    /**
     * True if `latestSnapshot` contains all messages in the conversation.
     * Use `MessageSubscription.loadMore` to load more.
     */
    loadedAll: boolean;
}

/**
 * Encapsulates the message entry field tied to the currently selected conversation.
 * @public
 */
export declare interface MessageField {
    /**
     * Focuses the message entry field.
     *
     * @remarks
     * Note that on mobile devices, this will cause the on-screen keyboard to pop up, obscuring part
     * of the screen.
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     */
    focus(): void;
    /**
     * Sets the message field to `text`.
     *
     * @remarks
     * Useful if you want to guide your user with message suggestions. If you want to start a UI
     * with a given text showing immediately, call this method before calling {@link Inbox.mount}
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     *
     * @param text - The text to be displayed in the message entry field
     */
    setText(text: string): void;
    /**
     * Types the given `text` into the message field.
     *
     * @remarks
     * Inserts `text` wherever the cursor currently is.
     *
     * This method may be useful for various bot/simulation scenarios. Additionally, it lets you make
     * it so that any regular keypress lets the user start typing into the message field, even if it
     * is not focused.
     *
     * This method will silently fail if the participant only has "Read" access in the
     * current conversation.
     *
     * To do that, capture the keypress using a regular window event listener, ensure that the user
     * isn't typing into a different input, and then call this method to type the key, followed by
     * {@link MessageField.focus}. Note that TalkJS already does this out-of-the box when the chat UI
     * iframe has focus and {@link ChatboxOptions.captureKeyboardEvents} is off.
     *
     * @param text - The text to be inserted in the message entry field
     */
    typeText(text: string): void;
    /**
     * Gets the current content of the message field.
     */
    getText(): Promise<string>;
    /**
     * Sets the visibility of the Message Field to a given value or to a certain predicate.
     *
     * @remarks
     * See {@link MessageFieldOptions.visible} for examples.
     *
     * @param visible - boolean or a more advanced predicate.
     */
    setVisible(visible: boolean | ConversationPredicate): void;
}

/**
 * @public
 */
export declare interface MessageFieldOptions {
    /**
     * If set to `true`, pressing the enter key sends the message (if there is text in the message
     * field). When set to `false`, the only way to send a message is by clicking or touching the
     * "Send" button. Defaults to `true`.
     */
    enterSendsMessage?: boolean;
    /**
     * Specifies whether the
     * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea#attr-spellcheck | spellcheck}
     * attribute is set on the message field. Note that setting this to `true` may also enable
     * autocorrect on some mobile devices. Defaults to `false`.
     */
    spellcheck?: boolean;
    /**
     * Overrides the placeholder text that is displayed in the message field when no text has yet been entered.
     *
     * Defaults to "Say something..." (or a {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | translation thereof}).
     */
    placeholder?: string;
    /**
     * Determines whether the message field is visible. Pass either a boolean (`false` to hide it),
     * or a {@link ConversationPredicate}. The latter approach lets you show/hide the message field
     * based on properties of the current conversation.
     *
     * For example, to hide the message field when the current user has no write access to the
     * current conversation, do the following:
     *
     * ```js
     * // this predicate holds iff the current user's `access` to the current conversation is
     * // set to "ReadWrite"`:
     * const showMessageField = { access: ["==", "ReadWrite"] };
     * session.createInbox(conversation, { messageField: { visible: showMessageField } });
     * ```
     *
     * Defaults to `true`.
     */
    visible?: boolean | ConversationPredicate;
    /**
     * Determines whether the message field should automatically focus when the user navigates.
     *
     * The default option is `"smart"`, which means that focus is switched to the message field
     * whenever a conversation is selected, if it is possible to do this without negative side effects.
     * This is possible when:
     *
     * - The message field is inside the browser viewport (so focusing will not unexpectedly cause
     *   the page to scroll)
     *
     * - The user is likely on a desktop/laptop computer (so focusing will not unexpectedly expand a
     *   mobile on-screen keyboard).
     *
     * Note: If you need more control, consider setting `autofocus` to false and calling
     * {@link MessageField.focus} at appropriate times.
     */
    autofocus?: false | "smart";
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}.
 *
 * The MessagePredicate can be either of the following:
 *
 * - a single SimpleMessagePredicate object that filters based on all the fields of the predicate
 *
 * - an array that gives you all the messages that satisfy at least one of the SimpleMessagePredicates
 *
 * See {@link SimpleMessagePredicate} and {@link CompoundMessagePredicate} for all available options.
 *
 * @public
 */
export declare type MessagePredicate = SimpleMessagePredicate | CompoundMessagePredicate;

/**
 * References the message with a given message ID.
 *
 * @remarks
 * Used in all Realtime API operations affecting that message, such as fetching or editing the message attributes, or deleting the message.
 * Created via {@link ConversationRef.message}.
 *
 * @public
 */
export declare interface MessageRef {
    /**
     * The ID of the referenced message.
     *
     * @remarks
     * Immutable: if you want to reference a different message, get a new MessageRef instead.
     */
    readonly id: string;
    /**
     * The ID of the conversation that the referenced message belongs to.
     *
     * @remarks
     * Immutable: if you want to reference a message from a different conversation, get a new MessageRef from that conversation.
     */
    readonly conversationId: string;
    /**
     * Fetches a snapshot of the message.
     *
     * @remarks
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#cached-fetch | Cached Fetch}
     *
     * @returns A snapshot of the message's attributes, or null if the message doesn't exist, the conversation doesn't exist, or you're not a participant in the conversation.
     */
    get(): Promise<MessageSnapshot | null>;
    /**
     * Edits this message.
     *
     * @returns A promise that resolves when the operation completes. The promise will reject if the request is invalid, the message doesn't exist, or you do not have permission to edit that message.
     */
    edit(params: string | EditTextMessageParams | EditMessageParams): Promise<void>;
    /**
     * Deletes this message, or does nothing if they are already not a participant.
     *
     * @remarks
     * Deleting a nonexistent message is treated as success, and the promise will resolve.
     *
     * @returns A promise that resolves when the operation completes. This promise will reject if you are not a participant in the conversation or if your role does not give you permission to delete this message.
     */
    delete(): Promise<void>;
}

/**
 * A snapshot of a message's attributes at a given moment in time.
 *
 * @remarks
 * Automatically expanded to include a snapshot of the user that sent the message, and a snapshot of the referenced message, if this message is a reply.
 *
 * Snapshots are immutable and we try to reuse them when possible. You should only re-render your UI when `oldSnapshot !== newSnapshot`.
 *
 * @public
 */
export declare interface MessageSnapshot {
    /**
     * The unique ID that is used to identify the message in TalkJS
     */
    id: string;
    /**
     * Whether this message was "from a user" or a general system message without a specific sender.
     *
     * The `sender` property is always present for "UserMessage" messages and never present for "SystemMessage" messages.
     */
    type: "UserMessage" | "SystemMessage";
    /**
     * A snapshot of the user who sent the message, or null if it is a system message.
     * The user's attributes may have been updated since they sent the message, in which case this snapshot contains the updated data.
     * It is not a historical snapshot.
     */
    sender: UserSnapshot | null;
    /**
     * Custom metadata you have set on the message
     */
    custom: Record<string, string>;
    /**
     * Time at which the message was sent, as a unix timestamp in milliseconds
     */
    createdAt: number;
    /**
     * Time at which the message was last edited, as a unix timestamp in milliseconds.
     * `null` if the message has never been edited.
     */
    editedAt: number | null;
    /**
     * A snapshot of the message that this message is a reply to, or null if this message is not a reply.
     *
     * @remarks
     * Only UserMessages can reference other messages.
     * The referenced message snapshot does not have a `referencedMessage` field.
     * Instead, it has `referencedMessageId`.
     * This prevents TalkJS fetching an unlimited number of messages in a long chain of replies.
     */
    referencedMessage: ReferencedMessageSnapshot | null;
    /**
     * Where this message originated from:
     *
     * - "web" = Message sent via the UI or via {@link ConversationBuilder.sendMessage}
     *
     * - "rest" = Message sent via the REST API's "send message" endpoint or {@link ConversationRef.send}
     *
     * - "import" = Message sent via the REST API's "import messages" endpoint
     *
     * - "email" = Message sent by replying to an email notification
     */
    origin: "web" | "rest" | "import" | "email";
    /**
     * The contents of the message, as a plain text string without any formatting or attachments.
     * Useful for showing in a conversation list or in notifications.
     */
    plaintext: string;
    /**
     * The main body of the message, as a list of blocks that are rendered top-to-bottom.
     */
    content: ContentBlock[];
}

/**
 * A subscription to the messages in a specific conversation.
 *
 * @remarks
 * Get a MessageSubscription by calling {@link ConversationRef.subscribeMessages}
 *
 * The subscription is 'windowed'. It includes all messages since a certain point in time.
 * By default, you subscribe to the 30 most recent messages, and any new messages are sent after you subscribe.
 *
 * You can expand this window by calling `loadMore`, which extends the window further into the past.
 *
 * @public
 */
export declare interface MessageSubscription {
    /**
     * The current state of the subscription
     *
     * @remarks
     * An object with the following fields:
     *
     * `type` is one of "pending", "active", "unsubscribed", or "error".
     *
     * When `type` is "active", includes `latestSnapshot` and `loadedAll`.
     *
     * - `latestSnapshot: MessageSnapshot[] | null` the current state of the messages in the window, or null if you're not a participant in the conversation
     *
     * - `loadedAll: boolean` true when `latestSnapshot` contains all the messages in the conversation
     *
     * When `type` is "error", includes the `error` field. It is a JS `Error` object explaining what caused the subscription to be terminated.
     */
    state: PendingState | MessageActiveState | UnsubscribedState | ErrorState;
    /**
     * Resolves when the subscription starts receiving updates from the server.
     *
     * @remarks
     * Wait for this promise if you want to perform some action as soon as the subscription is active.
     *
     * The promise rejects if the subscription is terminated before it connects.
     */
    connected: Promise<MessageActiveState>;
    /**
     * Resolves when the subscription permanently stops receiving updates from the server.
     *
     * @remarks
     * This is either because you unsubscribed or because the subscription encountered an unrecoverable error.
     */
    terminated: Promise<UnsubscribedState | ErrorState>;
    /**
     * Expand the window to include older messages
     *
     * @remarks
     * Calling `loadMore` multiple times in parallel will still only load one page of messages.
     *
     * @param count - The number of additional messages to load. Must be between 1 and 100
     * @returns A promise that resolves once the additional messages have loaded
     */
    loadMore: (count?: number) => Promise<void>;
    /**
     * Unsubscribe from this resource and stop receiving updates.
     *
     * @remarks
     * If the subscription is already in the "unsubscribed" or "error" state, this is a no-op.
     */
    unsubscribe(): void;
}

/**
 * @public
 * A two-element array that forms a predicate about a numeric field.
 *
 * @remarks
 * Used in {@link ConversationPredicate}.
 * Possible forms:
 *
 * - `[">", someNumber]`
 *
 * - `["<", someNumber]`
 *
 * - `[">=", someNumber]`
 *
 * - `["<=", someNumber]`
 *
 * - `["between", [lowerBound, upperBound]]`
 *
 * - `["!between", [lowerBound, upperBound]]`
 */
export declare type NumberPredicate = [">" | "<" | ">=" | "<=", number] | ["between" | "!between", [number, number]];

/**
 * A helper method to predictably compute a Conversation ID based on participants' ids in the given conversation.
 * Use this method if you want to simply create a conversation between two users,
 * not related to a particular product, order or transaction.
 *
 * The order of the parameters does not matter.
 * For example, `Talk.oneOnOneId("a", "b")` yields the same result as `Talk.oneOnOneId("b", "a")`.
 *
 * This method takes the following steps:
 * 1. Take two ids of users and put them in an array
 * 2. Sort them lexicographically
 * 3. JSON encode them
 * 4. hash the result using SHA1, return the first 20 characters
 *
 * In pseudocode, this is what this function does:
 *
 *     var sorted = [me.id, other.id].sort()
 *     var encoded = JSON.encode(sorted)
 *     var hash = sha1(encoded)             // as lowercase hex
 *     return truncate(hash, 20)
 *
 * For a PHP implementation, see https://gist.github.com/eteeselink/4dc3ad32cc478986ff2b5b6361a1825f.
 * {@link https://talkjs.com/?chat | Get in touch} if you need our help implementing this in your backend language.
 * @public
 */
export declare function oneOnOneId(me: User | string, other: User | string): string;

/**
 * @public
 * @hidden due to being empty
 * @deprecated Use `popup.onOpen(() => {...})` instead, without an event parameter
 */
export declare interface OpenEvent {
}

/**
 * @public
 * @hidden
 * Contains information about an individual participant
 */
export declare interface Participant {
    /**
     * A Talk JS {@link User}
     */
    readonly user: User;
    /**
     * Contains access and notification settings for a given user's participation to a given conversation. Used in ConversationBuilder.setParticipant.
     */
    readonly participationSettings: Partial<ParticipationSettings>;
}

/**
 * References a given user's participation in a conversation.
 *
 * @remarks
 * Used in all Realtime API operations affecting that participant, such as joining/leaving a conversation, or setting their access.
 * Created via {@link ConversationRef.participant}.
 *
 * @public
 */
export declare interface ParticipantRef {
    /**
     * The ID of the user who is participating.
     *
     * @remarks
     * Immutable: if you want to reference a different participant, get a new ParticipantRef instead.
     */
    readonly userId: string;
    /**
     * The ID of the conversation the user is participating in.
     *
     * @remarks
     * Immutable: if you want to reference the user in a different conversation, get a new ParticipantRef instead.
     */
    readonly conversationId: string;
    /**
     * Fetches a snapshot of the participant.
     *
     * @remarks
     * This contains all of the participant's public information.
     *
     * @returns A snapshot of the participant's attributes, or null if the user is not a participant. The promise will reject if you are not a participant and try to read information about someone else.
     */
    get(): Promise<ParticipantSnapshot | null>;
    /**
     * Sets properties of this participant. If the user is not already a participant in the conversation, they will be added.
     *
     * @remarks
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#automatic-batching | Automatic Batching}
     *
     * @returns A promise that resolves when the operation completes.
     * When client-side conversation syncing is disabled, you may only set your `notify` property, when you are already a participant.
     * Everything else requires client-side conversation syncing to be enabled, and will cause the promise to reject.
     */
    set(params: SetParticipantParams): Promise<void>;
    /**
     * Edits properties of a pre-existing participant. If the user is not already a participant in the conversation, the promise will reject.
     *
     * @remarks
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#automatic-batching | Automatic Batching}
     *
     * @returns A promise that resolves when the operation completes.
     * When client-side conversation syncing is disabled, you may only set your `notify` property, when you are already a participant.
     * Everything else requires client-side conversation syncing to be enabled, and will cause the promise to reject.
     */
    edit(params: SetParticipantParams): Promise<void>;
    /**
     * Adds the user as a participant, or does nothing if they are already a participant.
     *
     * @remarks
     * If the participant already exists, this operation is still considered successful and the promise will still resolve.
     *
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#automatic-batching | Automatic Batching}
     *
     * @returns A promise that resolves when the operation completes. The promise will reject if client-side conversation syncing is disabled and the user is not already a participant.
     */
    createIfNotExists(params?: CreateParticipantParams): Promise<void>;
    /**
     * Removes the user as a participant, or does nothing if they are already not a participant.
     *
     * @remarks
     * Deleting a nonexistent participant is treated as success, and the promise will resolve.
     *
     * @returns A promise that resolves when the operation completes. This promise will reject if client-side conversation syncing is disabled.
     */
    delete(): Promise<void>;
}

/**
 * A snapshot of a participant's attributes at a given moment in time.
 *
 * @remarks
 * Automatically expanded to include a snapshot of the user who is a participant.
 *
 * Snapshots are immutable and we try to reuse them when possible. You should only re-render your UI when `oldSnapshot !== newSnapshot`.
 *
 * @public
 */
export declare interface ParticipantSnapshot {
    /**
     * The user who this participant snapshot is referring to
     */
    user: UserSnapshot;
    /**
     * The level of access this participant has in the conversation.
     */
    access: "ReadWrite" | "Read";
    /**
     * When the participant will be notified about new messages in this conversation.
     *
     * @remarks
     * `false` means no notifications, `true` means notifications for all messages, and `"MentionsOnly"` means that the user will only be notified when they are mentioned with an `@`.
     */
    notify: boolean | "MentionsOnly";
    /**
     * The date that this user joined the conversation, as a unix timestamp in milliseconds.
     */
    joinedAt: number;
}

/**
 * Specifies access and notification settings for a given user's participation
 * to a given conversation. Used in {@link ConversationBuilder.setParticipant}.
 * @public
 */
export declare interface ParticipationSettings {
    /**
     * Specifies the participant's access permission for a conversation. See {@link ConversationBuilder.setParticipant}
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    access?: "Read" | "ReadWrite";
    /**
     * Specifies the participants's notification settings. See {@link ConversationBuilder.setParticipant}
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    notify?: boolean | "MentionsOnly";
}

/**
 * The state of a subscription before it has connected to the server
 *
 * @public
 */
export declare interface PendingState {
    type: "pending";
}

/**
 * @public
 *
 * A string that is one of `"notifications" | "microphone" | "geolocation"`.
 *
 * @remarks
 * Used in {@link BrowserPermissionNeededEvent} and {@link BrowserPermissionDeniedEvent}
 *
 * Note that more possible values may be added in the future, so make sure your
 * handler can deal with unknown permission types gracefully.
 */
export declare type PermissionType = "notifications" | "microphone" | "geolocation";

/**
 * A messaging UI for just a single conversation.
 *
 * There is no way for the user to switch between conversations
 * (but you can change the active conversation through {@link Popup.select}).
 * Create a Popup through {@link Session.createPopup} and then call
 * {@link Popup.mount} to show it.
 * @public
 */
export declare interface Popup extends UIBox {
    /**
     * Renders the Popup UI on your page
     *
     * @remarks
     * Loads the popup in the background, but by default shows only the launcher button. Pass
     * `{ show: true }` to open the popup as soon as it's loaded.
     */
    mount(options?: {
        show?: boolean;
    }): Promise<void>;
    /**
     * Destroys the popup and removes it from the DOM
     *
     * @remarks
     * Destroys the popup, removes it from the DOM and removes all event listeners it has running.
     */
    destroy(): void;
    /**
     * Shows the Popup
     *
     * @remarks
     * Use this to show a popup that was previously hidden or mounted with a parameter `show: false`.
     * Note: does nothing on unmounted popups. Make sure you call {@link Popup.mount} once before you call `show()` or {@link Popup.hide}.
     */
    show(): void;
    /**
     * Closes the popup, but doesn't remove it from the DOM
     */
    hide(): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onOpen} instead.
     */
    on(eventType: "open", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onClose} instead.
     */
    on(eventType: "close", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     * @deprecated Please use {@link Popup.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("open")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onOpen} instead.
     */
    off(eventType: "open", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("close")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onClose} instead.
     */
    off(eventType: "close", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link Popup.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("keyup")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Popup.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Triggers when the popup is opened by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to open the popup.
     * This event is not triggered when you call {@link Popup.show} or when you
     * {@link Popup.mount} it with the `{show: true}` option.
     */
    onOpen(handler: () => void): Subscription;
    /**
     * Triggers when the popup is closed by the user
     *
     * @remarks
     * Only gets triggered when the user performs an action to close the popup,
     * eg when they click the "X" on the launcher or,
     * {@link PopupOptions.showCloseInHeader | if enabled}, in the popup header.
     * This event is not triggered when you call {@link Popup.hide} or
     * {@link Popup.destroy}.
     */
    onClose(handler: () => void): Subscription;
}

/**
 * @alias UIBox Popup
 * @public
 */
export declare interface PopupOptions extends ChatboxOptions {
    /**
     * If enabled, the Popup will reopen every time
     * the user navigates to another page. This way, a conversation can continue
     * while the user browses around. Set to `false` to disable this behavior.
     *
     * Defaults to false.
     */
    keepOpen?: boolean;
    /**
     * Specifies whether to show a round
     * launcher and/or close button beneath the popup in the right bottom corner
     * of the page.
     *
     * @remarks
     * `"close-only"`: show a close button beneath the popup, but don't show a launch button
     *
     * `"always"`: show a launch button when the popup is closed, show a close button when it is visible
     *
     * `"never"`: never show a launcher
     *
     * Note: if you choose `"never"` you may want to override the positioning of the popup as well.
     * Just tune the `__talkjs_popup` class in your CSS.
     *
     * Ignored on mobile, where the popup fills the entire screen so the value is effectively `"never"`.
     *
     * Defaults to `"always"`.
     *
     */
    launcher?: "close-only" | "always" | "never";
    /**
     * Whether to show the "x" icon in the popup header to close the popup.
     * "auto", which is the default value means `true` on mobile and to `false` on desktop.
     */
    showCloseInHeader?: boolean | "auto";
}

/**
 * @public
 */
export declare interface PushRegistrationOptions {
    /**
     * The push message provider to use: Google's Firebase Cloud Messaging (`fcm`)
     * or Apple's APNs (`apns`).
     */
    provider: "fcm" | "apns";
    /**
     * The APNs {@link https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/HandlingRemoteNotifications.html#//apple_ref/doc/uid/TP40008194-CH6-SW4|device token} or the FCM {@link https://firebase.google.com/docs/cloud-messaging/android/client|registration token}.
     */
    pushRegistrationId: string;
}

/** @public */
export declare const ready: Promise<void>;

/**
 * A snapshot of a message's attributes at a given moment in time, used in {@link MessageSnapshot.referencedMessage}.
 *
 * @remarks
 * Automatically expanded to include a snapshot of the user that sent the message.
 * Since this is a snapshot of a referenced message, its referenced message is not automatically expanded, to prevent fetching an unlimited number of messages in a long chain of replies.
 * Instead, contains the `referencedMessageId` field.
 *
 * Snapshots are immutable and we try to reuse them when possible. You should only re-render your UI when `oldSnapshot !== newSnapshot`.
 *
 * @public
 */
export declare interface ReferencedMessageSnapshot {
    /**
     * The unique ID that is used to identify the message in TalkJS
     */
    id: string;
    /**
     * Referenced messages are always "UserMessage" because you cannot reply to a system message.
     */
    type: "UserMessage";
    /**
     * A snapshot of the user who sent the message.
     * The user's attributes may have been updated since they sent the message, in which case this snapshot contains the updated data.
     * It is not a historical snapshot.
     *
     * @remarks
     * Guaranteed to be set, unlike in MessageSnapshot, because you cannot reference a SystemMessage
     */
    sender: UserSnapshot;
    /**
     * Custom metadata you have set on the message
     */
    custom: Record<string, string>;
    /**
     * Time at which the message was sent, as a unix timestamp in milliseconds
     */
    createdAt: number;
    /**
     * Time at which the message was last edited, as a unix timestamp in milliseconds.
     * `null` if the message has never been edited.
     */
    editedAt: number | null;
    /**
     * The ID of the message that this message is a reply to, or null if this message is not a reply.
     *
     * @remarks
     * Since this is a snapshot of a referenced message, we do not automatically expand its referenced message.
     * The ID of its referenced message is provided here instead.
     */
    referencedMessageId: string | null;
    /**
     * Where this message originated from:
     *
     * - "web" = Message sent via the UI or via `ConversationBuilder.sendMessage`
     *
     * - "rest" = Message sent via the REST API's "send message" endpoint
     *
     * - "import" = Message sent via the REST API's "import messages" endpoint
     *
     * - "email" = Message sent by replying to an email notification
     */
    origin: "web" | "rest" | "import" | "email";
    /**
     * The contents of the message, as a plain text string without any formatting or attachments.
     * Useful for showing in a conversation list or in notifications.
     */
    plaintext: string;
    /**
     * The main body of the message, as a list of blocks that are rendered top-to-bottom.
     */
    content: ContentBlock[];
}

/**
 * @public
 * Event data triggered from {@link Inbox.onSelectConversation}.
 */
export declare interface SelectConversationEvent {
    /**
     * The current TalkJS User
     */
    me: UserSnapshot;
    /**
     * @deprecated When you are the only participant in the conversation, this property includes the current user. Use `participants` and filter out the current user instead.
     *
     * The other participants in the conversation that are not the current user
     */
    others: Array<UserSnapshot>;
    /**
     * The participants in the conversation, including the current user
     */
    participants: Array<UserSnapshot>;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * The id of the message to scroll to (This property only exists when a message search result has been selected)
     */
    messageId?: string;
    /**
     * Prevents the clicked conversation from being selected.
     */
    preventDefault(): void;
}

/**
 * @public
 * Selection parameters.
 */
export declare interface SelectConversationOptions {
    /**
     * can be used to select the conversation as a guest, with limited functions
     */
    asGuest?: boolean;
    /**
     * can be used to scroll to a specific message
     */
    messageId?: string;
}

/**
 * The version of {@link ContentBlock} that is used when sending or editing messages.
 *
 * @remarks
 * This is the same as {@link ContentBlock} except it uses {@link SendFileBlock} instead of {@link FileBlock}
 *
 * `SendContentBlock` is a subset of `ContentBlock`.
 * This means that you can re-send the `content` from an existing message without any issues:
 *
 * ```
 * const existingMessage: MessageSnapshot = ...;
 *
 * const convRef = session.conversation('example_conversation_id');
 * convRef.send({ content: existingMessage.content });
 * ```
 *
 * @public
 */
export declare type SendContentBlock = TextBlock | SendFileBlock | LocationBlock;

/**
 * @public
 */
export declare interface SenderPredicate {
    /**
     * Only show messages from a sender(s) with a given id.
     *
     * For example:
     *
     * ```js
     * // Don't show messages sent by user with ID 1
     * {sender: {id: ["!=", "1"]}}
     * ```
     */
    id?: FieldPredicate<string>;
    /**
     * Only show messages from senders with a given locale.
     *
     * For example:
     *
     * ```js
     * // Only show messages from senders with locale: en-GB or en-US
     * {sender: {locale: ["oneOf", ["en-GB", "en-US"]}}
     * ```
     */
    locale?: FieldPredicate<string>;
    /**
     * Only show messages from senders who have a particular role.
     *
     * For example:
     *
     * ```js
     * // Only show messages from senders with role: Admin and locale: en-GB
     * {sender: {role: ["==", "Admin"], locale: ["==", "en-GB"]}}
     * ```
     */
    role?: FieldPredicate<string>;
    /**
     * Only show messages from senders who have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in a user's custom data that you have set. It is not necessary for all
     * senders to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Example, assume you have some users with the `alternateRole` field in their custom data:
     *
     * ```js
     * // Only show messages from senders that have the field alternateRole set:
     * {custom: {alternateRole: "!exists" }}
     *
     * // Only show messages from senders that have the field alternateRole set to "support":
     * {custom: {alternateRole: ["==", "support"]}}
     * ```
     *
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
}

/**
 * The version of {@link FileBlock} that is used when sending or editing messages.
 *
 * @remarks
 * When a user receives the message you send with `SendFileBlock`, this block will have turned into one of the {@link FileBlock} variants.
 *
 * For information on how to obtain a file token, see {@link FileToken}.
 *
 * The `SendFileBlock` interface is a subset of the `FileBlock` interface.
 * If you have an existing `FileBlock` received in a message, you can re-use that block to re-send the same attachment:
 *
 * ```
 * const existingFileBlock = ...;
 * const imageToShare = existingFileBlock.content[0] as ImageBlock
 *
 * const convRef = session.conversation('example_conversation_id');
 * convRef.send({ content: [imageToShare] });
 * ```
 *
 * @public
 */
export declare interface SendFileBlock {
    type: "file";
    /**
     * The encoded identifier for the file, obtained by uploading a file with {@link Session.sendFile}, or taken from another message.
     */
    fileToken: FileToken;
}

/**
 * @public
 * The event triggered when listening for the sendMessage event on the {@link Inbox}, {@link Chatbox} and {@link Popup}.
 * This event is triggered before the message is sent to TalkJS, allowing you to modify the contents of the message or its metadata by
 * using `override()`.
 */
export declare interface SendMessageEvent {
    /**
     * The message that was sent
     */
    message: SentMessage;
    /**
     * The current TalkJS user
     */
    me: UserSnapshot;
    /**
     * The current conversation object
     */
    conversation: ConversationData;
    /**
     * This function allows you to modify the contents of the message or its
     * metadata before the message is sent.
     *
     * @remarks Pass an object with `text` and/or `custom` fields, see
     * {@link SendMessageOverrideParams}.
     *
     * You can either pass the overridden data directly, or a (possibly async)
     * function that computes it.
     *
     * Note that if you pass an async function, it must resolve as quickly as
     * possible, because the chat UI cannot update before it does. This may make
     * chat UX feel sluggish. If it does not resolve within 5 seconds, the message
     * is sent unmodified.
     */
    override: (params: SendMessageOverrideParams | (() => SendMessageOverrideParams | Promise<SendMessageOverrideParams>)) => void;
}

/**
 * @public
 */
export declare interface SendMessageOptions {
    /**
     * An object with any custom data that you may wish to associate with this message. The custom data is sent back to you via webhooks and the REST API.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: CustomData;
}

/**
 * @public
 */
export declare interface SendMessageOverrideParams {
    text?: string;
    custom?: CustomData;
}

/**
 * Parameters you can pass to {@link ConversationRef.send}.
 *
 * @remarks
 * Properties that are `undefined` will be set to the default.
 *
 * This is the more advanced method for editing a message, giving full control over the message content.
 * You can decide exactly how a text message should be formatted, edit an attachment, or even turn a text message into a location.
 *
 * @public
 */
export declare interface SendMessageParams {
    /**
     * Custom metadata you have set on the user.
     * Default = no custom metadata
     */
    custom?: Record<string, string>;
    /**
     * The message that you are replying to.
     * Default = not a reply
     */
    referencedMessage?: string | MessageRef;
    /**
     * The most important part of the message, either some text, a file attachment, or a location.
     *
     * @remarks
     * By default users do not have permission to send {@link LinkNode}, {@link ActionLinkNode}, or {@link ActionButtonNode}, as they can be used to trick the recipient.
     */
    content: [SendContentBlock];
}

/**
 * Parameters you can pass to {@link ConversationRef.send}.
 *
 * @remarks
 * Properties that are `undefined` will be set to the default.
 *
 * This is a simpler version of {@link SendMessageParams} that only supports text messages.
 *
 * @public
 */
export declare interface SendTextMessageParams {
    /**
     * Custom metadata you have set on the user.
     * Default = no custom metadata
     */
    custom?: Record<string, string>;
    /**
     * The message that you are replying to.
     * Default = not a reply
     */
    referencedMessage?: string | MessageRef;
    /**
     * The text to send in the message.
     *
     * @remarks
     * This is parsed the same way as the text entered in the message field. For example, `*hi*` will appear as `hi` in bold.
     *
     * See the {@link https://talkjs.com/docs/Features/Message_Features/Formatting/ | message formatting documentation} for more details.
     */
    text: string;
}

/**
 * @public
 * A message that was sent to TalkJS
 */
export declare interface SentMessage {
    /**
     * The message ID of the message that was sent
     */
    id: string | undefined;
    /**
     * The ID of the conversation that the message belongs to
     */
    conversationId: string;
    /**
     * Identifies the message as either a {@link https://talkjs.com/docs/Reference/Concepts/Messages.html | User message} or
     * {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | System message}
     */
    type: "UserMessage" | "SystemMessage";
    /**
     * Contains an Array of {@link User.id}'s that have read the message
     */
    readBy: string[];
    /**
     * Contains the user ID for the person that sent the message
     */
    senderId: string;
    /**
     * Contains the message's text
     */
    text?: string;
    /**
     * Only given if the message contains a file. An object with the URL and filesize (in bytes) of the given file. Attachment dimensions (in px) are sometimes available for image and video attachments, used to set the size of the thumbnail before loading, to prevent content shift when loading media on slower connections.
     */
    attachment?: Attachment;
    /**
     * Only given if the message contains a location. An array of two numbers which represent the longitude and latitude of this location, respectively. Only given if this message is a shared location.
     *
     * Example:
     *
     * ```js
     * [51.481083, -3.178306]
     * ```
     */
    location?: [number, number];
}

/**
 * A session represents a user's active browser tab. It also authenticates your app
 * with TalkJS.
 *
 * @public
 */
export declare class Session {
    private readonly _onEventSubscription;
    private readonly _eventEmitter;
    private _uiBoxes;
    /**
     * Whether the session is active and in a valid state.
     *
     * @remarks
     * When false, calling methods on this Session instance will throw errors.
     *
     * This field is false when {@link Session.destroy} has been called in the
     * past. Once a session has been destroyed, you cannot revive it. Instead,
     * create a new session.
     */
    isAlive: boolean;
    /**
     * Holds information about unread conversations. Lets your app be notified
     * when the active user receives a new message.
     */
    readonly unreads: Unreads;
    /** The TalkJS {@link User} associated with the current user in your application. */
    readonly me: User;
    /**
     * A reference to the current user
     * @public
     */
    readonly currentUser: UserRef;
    /**
     * Get a reference to a user, for use with the Realtime API
     *
     * @param id - The ID of the user that you want to reference
     * @returns A UserRef for the user with that ID
     * @public
     */
    user(id: string): UserRef;
    /**
     * Get a reference to a conversation, for use with the Realtime API
     *
     * @param id - The ID of the conversation that you want to reference
     * @returns A ConversationRef for the conversation with that ID
     * @public
     */
    conversation(id: string): ConversationRef;
    /** Your TalkJS `AppId` that can be found on the "Settings" page of your TalkJS {@link https://talkjs.com/dashboard | dashboard}. */
    readonly appId: string;
    private readonly _sessionId;
    /**
     * Creates a TalkJS Session.
     * @public
     */
    constructor(options: SessionOptions);
    /**
     * Verifies whether the `appId` is valid.
     *
     * @remarks
     * Returns a Promise of a boolean, never rejects.
     */
    hasValidCredentials(): Promise<boolean>;
    private _maybeRestorePopup;
    private _trackWindowFocus;
    /**
     * @deprecated This method will keep being supported, but for new projects, we
     * recommend that you use {@link Session.getOrCreateConversation}.
     *
     * @param other - A `User` object that identifies the person to converse with.
     * The user is uniquely identified by their id; all other fields (name, photo
     * etc) are overwritten in the TalkJS database each  time they change.
     * @param options - Options used for getOrStartConversation
     *
     * @returns a `Conversation` object that encapsulates a conversation between
     * `me` (given in the constructor) and `other`.
     *
     * @hidden
     */
    getOrStartConversation(other: User, options?: GetOrStartOptionsA): Conversation;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.getOrCreateConversation}.
     *
     * @param conversationId - A unique identifier for this conversation. Any user with access to
     *                         this ID can join this conversation.
     *
     * @param options - Options used for getOrStartConversation
     *
     * @returns a `Conversation` object that encapsulates a conversation between `me` (given in the
     * constructor) and zero or more other `participants`.
     *
     * @hidden
     */
    getOrStartConversation(conversationId: string, options?: GetOrStartOptionsB): Conversation;
    private _maybeAddMyParticipant;
    /**
     * A method used to either fetch or create a conversation.
     *
     * @remarks
     * Returns a `ConversationBuilder` object that encapsulates a conversation
     * between `me` (given in the constructor) and zero or more other `participants`.
     * Use {@link ConversationBuilder.setParticipant} and {@link ConversationBuilder.setAttributes}
     * on the returned object to further set up your conversation.
     *
     * @param conversationId - A unique identifier for this conversation, such as a channel name or topic ID.
     * Any user with access to this ID can join this conversation. {@link https://talkjs.com/docs/Reference/Concepts/Conversations.html | Read about how to choose a good conversation ID for your use case}.
     * If you want to make a simple one-on-one conversation, consider using {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/The_Talk_Object/#Talk.oneOnOneId | oneOnOneId} to generate one.
     */
    getOrCreateConversation(conversationId: string): ConversationBuilder;
    /**
     * Creates an Inbox UI
     *
     * @remarks
     * The Inbox is TalkJS's most versatile component. It combines a
     * {@link Chatbox} with a panel showing a a list of conversations where the
     * user is a participant. In order to select a conversation inside an Inbox
     * you need to call {@link Inbox.select}.
     *
     * Example:
     * ```js
     * const inbox = session.createInbox();
     * inbox.select(conversation);
     * ```
     *
     * You typically want to call {@link Inbox.mount} after creating the Inbox to
     * make it visible on your app.
     *
     * Call `createInbox` on the messaging page of your app.
     *
     * @param options - Optional. Use these to finetune the behavior of the Inbox.
     */
    createInbox(options?: InboxOptions): Inbox;
    /**
     * Creates a Chatbox UI.
     *
     * @remarks
     * The Chatbox is a slimmer version of the Inbox. It shows a single conversation,
     * without means to switch between conversations. In order to select a conversation inside a Chatbox
     * you need to call {@link Chatbox.select}.
     *
     * Example:
     * ```js
     * const chatbox = session.createChatbox();
     * chatbox.select(conversation);
     * ```
     *
     * You typically want to call {@link Chatbox.mount} after creating the Chatbox to make it visible on your app.
     *
     *
     * Call `createChatbox` on any page you want to show a chatbox of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     *
     * @param options - Optional, Use these to finetune the behavior of the Chatbox.
     */
    createChatbox(options?: ChatboxOptions): Chatbox;
    /**
     * @public
     * @deprecated Instead, do `const chatbox = session.createChatbox(options); chatbox.select(conversation);`.
     * @hidden
     */
    createChatbox(conversation: Conversation | ConversationBuilder | null | undefined, options?: ChatboxOptions): Chatbox;
    /**
     * @public
     * @deprecated Instead, do `const popup = session.createPopup(options); popup.select(conversation);`.
     * @hidden
     */
    createPopup(conversation: Conversation | ConversationBuilder | null | undefined, options?: PopupOptions): Popup;
    /**
     * Creates a Popup UI.
     *
     * @remarks
     * The Popup is a positioned box containing a conversation. It shows a single conversation,
     * without means to switch between conversations.
     * In order to select a conversation inside a Popup
     * you need to call the {@link Popup.select}.
     *
     * Example:
     * ```js
     * const popup = session.createPopup();
     * popup.select(conversation);
     * ```
     *
     * You typically want to call {@link Popup.mount} after creating the popup to make it visible on your app.
     *
     *
     * Call `createPopup` on any page you want to show a popup of a single conversation.
     *
     * Note: A deprecated two-parameter form of this method, `createChatbox(selectedConversation, options)`, also exists. This form will keep being supported but we recommend not using it new codebases. Instead, call {@link Chatbox.select} immediately after `mount`.
     * In order to have a popup on each site you need to call
     * `createPopup` on any page you want to show a popup with the conversation.
     *
     * @param options - Optional, Use these to finetune the behavior of the Popup.
     */
    createPopup(options?: PopupOptions): Popup;
    /**
     * Used to configure TalkJS to use a legacy theme hosted on the same location
     * as your application for development.
     *
     * @remarks
     * Tells TalkJS to use a theme hosted on the same location as your application
     * (e.g. localhost:8000/). e.g. Call
     * `talkSession.syncThemeForLocalDev("/assets/css/talkjs-theme.css")` just
     * before you call `createInbox` or `createChatbox`. TalkJS will then use the
     * specified file instead of using a theme created in the dashboard.
     *
     * @param path - The path to the legacy theme's CSS file
     *
     * @deprecated We recommend switching to
     * {@link https://talkjs.com/docs/Features/Themes/The_Theme_Editor/ | Custom Themes},
     * which are substantially more powerful and do not have a practical need for
     * a method like this.
     */
    syncThemeForLocalDev(path: string): void;
    /**
     * Sets desktop notification on or off.
     *
     * @remarks
     * Has the same effect as toggling the "Desktop notification" toggle in the
     * TalkJS Inbox UI. Use this function to replicate that toggle elsewhere in
     * your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * When desktop notifications are enabled for the first time, the browser will
     * show a prompt to ask the user for permission. The call will only succeed if
     * the user accepts it.
     *
     * We recommend only calling this function in response to user action, so
     * users know that they can expect a permission prompt. This significantly
     * increases the percentage of users that click "Allow".
     *
     * Notably, we strongly recommend that you do not call this function
     * immediately when the page loads, because many browsers auto block
     * notifications when permission is requested on page load. This is likely a
     * measure to prevent overly aggressive news sites from being able to spam
     * past visitors.
     *
     * @param isEnabled - Whether notifications should be enabled.
     * @param alertOnFailure - Whether to show an alert message when enabling
     * notifications fails. Defaults to `true`, unless you add a handler for
     * {@link Session.onBrowserPermissionDenied}, which emits an event when the
     * permission request fails. If there's a handler for that event, then this
     * defaults to false.
     *
     * @returns a promise that'll resolve if the change succeeds. If anything goes
     * wrong, the promise will reject with a {@link TalkError}, which has a `code`
     * property to indicate what went wrong. Possible values in this case are:
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_PERMISSION_DENIED`: The browser or the user
     *   didn't grant you permission to send notifications.
     *
     * - `Talk.ErrorCode.NOTIFICATIONS_NOT_SUPPORTED`: The browser doesn't support
     *   desktop notifications.
     */
    setDesktopNotificationEnabled(isEnabled: boolean, { alertOnFailure }?: {
        alertOnFailure?: boolean;
    }): Promise<void>;
    private _cleanUIBoxes;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setPushRegistration}.
     *
     * Registers mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.unregisterDevice | Session.unregisterDevice}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    registerDevice({ platform, pushRegistrationId, }: {
        platform: "ios" | "android";
        pushRegistrationId: string;
    }): Promise<void>;
    /**
     * @deprecated This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.unsetPushRegistration} or {@link Session.clearPushRegistrations}.
     *
     * Unregisters mobile device, one user can be connected to one mobile device.
     *
     * @remarks
     * Related method: {@link Session.registerDevice | Session.registerDevice}
     */
    unregisterDevice(): Promise<void>;
    /**
     * Registers a single mobile device, as one user can be connected to multiple mobile devices.
     *
     * @remarks
     * Related methods: {@link Session.unsetPushRegistration} {@link Session.clearPushRegistrations}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    setPushRegistration(options: PushRegistrationOptions): Promise<void>;
    /**
     * Unregisters a single mobile device, as one user can be connected to multiple mobile devices.
     *
     * @remarks
     * Related methods: {@link Session.setPushRegistration} {@link Session.clearPushRegistrations}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    unsetPushRegistration(options: PushRegistrationOptions): Promise<void>;
    /**
     * Unregisters all the mobile devices for the user.
     *
     * @remarks
     * Related methods: {@link Session.setPushRegistration} {@link Session.unsetPushRegistration}
     *
     * Note that you must ensure that the user exists in the TalkJS database before you call this
     * method. The simplest way to do that is to call it after you mount a chatbox, inbox or popup.
     */
    clearPushRegistrations(): Promise<void>;
    private _onNotificationClick;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * For an example, see {@link https://gist.github.com/eteeselink/607e585eb40be76f2ed150d4090e5261}
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}.
     * It only applies to users who were added as participants.
     *
     * Related method: {@link Session.off}
     *
     * @deprecated Please use {@link Session.onMessage} instead.
     */
    on(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Listens for an event
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link Session.setDesktopNotificationEnabled} and {@link Session.off}
     *
     * @deprecated Please use {@link Session.onDesktopNotificationClicked} instead.
     */
    on(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onMessage} instead.
     */
    off(eventType: "message", handler: (message: Message) => void): void;
    /**
     * Used to stop listening to specific TalkJS session events.
     *
     * @remarks
     * Call this with the same `eventType` and `handler` to stop receiving events.
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Session.onDesktopNotificationClicked} instead.
     */
    off(eventType: "desktopNotificationClicked", handler: (event: DesktopNotificationClickedEvent) => void): void;
    /**
     * Triggered when a message is sent in a conversation the current user is in.
     *
     * @remarks
     * A `"message"` event is fired every time a message is sent or received by the
     * current user (even if no TalkJS UI is visible). Your `handler` function is passed
     * a {@link Message} object with some information about each message and its conversation.
     *
     * Note that this event does not get triggered for conversations where the current user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}.
     * It only applies to users who were added as participants.
     *
     */
    onMessage(handler: (message: Message) => void): Subscription;
    /**
     * Listen for when a user clicks a desktop notification.
     *
     * @remarks
     * A `"desktopNotificationClicked"` event is fired every time a user clicks on a desktop notification
     * generated by TalkJS.
     *
     * When a user clicks on a notification, these things will happen:
     *
     * 1. The browser tab will be selected (note, this works in most browsers but cannot be guaranteed);
     *
     * 2. If you provided one or more "desktopNotificationClicked" handlers, they will be invoked in order;
     *
     * 3. If you did not, then the currently active inbox (if any) will jump to the conversation corresponding to the notification.
     *
     * See also {@link Session.setDesktopNotificationEnabled}
     */
    onDesktopNotificationClicked(handler: (event: DesktopNotificationClickedEvent) => void): Subscription;
    /**
     * Triggered when a browser permission prompt is about to be shown.
     *
     * @remarks
     * Certain features, such as sharing location, sending voice messages, or
     * receiving notificatons, only work if the user has granted your app the
     * relevant permissions. By default, TalkJS will trigger the browser's
     * built-in permissions dialog the first time such a feature is used.
     *
     * This event is triggered *just before* this browser permissions dialog is
     * shown. This lets you show custom UI elements that let you show the user
     * where to look, or explain that it's all safe.
     *
     * If you return a promise from your event handler, then TalkJS will wait
     * until this promise resolves before showing the permission dialog.
     *
     * Note that it is not guaranteed that this event will trigger: It will only
     * trigger if we are certain that a permission prompt is about to show, and
     * unfortunately we can't be certain of that in all browsers. More explicitly,
     * it will only trigger when the browser supports the [Permissions
     * API](https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API) with
     * the given notification type.
     *
     * Notably:
     *
     * * Safari below 15.6 (2022) does not support the Permissions API at all
     *
     * * Firefox does not support querying the "microphone" permission, which
     *   TalkJS needs for voice messages.
     *
     * In these situations, this event will never trigger.
     *
     * @see {@link Session.onBrowserPermissionDenied} for a way to receive an event when the browser or the user denies the requested permission.
     */
    onBrowserPermissionNeeded(handler: (event: BrowserPermissionNeededEvent) => Promise<any> | void): Subscription;
    /**
     * Triggered when the user tried to do an action that requires explicit
     * browser permission, but this permission was denied.
     *
     * @remarks
     * This can be caused by user actions such as the sharing a location, enabling
     * desktop notifications, or trying to record a voice message. These features
     * require the user to explicitly grant the browser permission.
     *
     * This event can be triggered in two situations:
     *
     * 1. The browser showed the user a permission prompt, and the user picked
     *    "Deny". In this case, this event will have been preceded by
     *    {@link Session.onBrowserPermissionNeeded}.
     *
     * 2. The user has denied the same permission in the past and the browser
     *    remembered this decision. In this case, the action will fail immediately
     *    and an {@link Session.onBrowserPermissionNeeded} event will not have
     *    been emitted.
     *
     * In either case, the user may be able to allow the permission in their
     * browser settings. The intended use of this event is to show the user an
     * alert or dialog telling them how.
     *
     * Note: by default, TalkJS may display an error message in an `alert` if a
     * permission is denied. If you listen to this event, then these messages are
     * suppressed under the assumption that you will provide your own UI for this.
     */
    onBrowserPermissionDenied(handler: (event: BrowserPermissionNeededEvent) => void): Subscription;
    /**
     * Disconnects all websockets, removes all UIs, and invalidates this session.
     *
     * @remarks
     * You cannot use any objects that were created in this session after you destroy it.
     *
     * If you want to use TalkJS after having called `destroy()` you must instantiate a new
     * Talk.Session instance.
     */
    destroy(): void;
    /**
     * Returns a list of all active {@link Popup} objects linked to this
     * session.
     *
     * @remarks
     * Includes popups actively created using {@link Session.createPopup}, and also
     * popups created on page load, if {@link PopupOptions.keepOpen} was set to
     * `true` on an earlier page.
     *
     * Only includes popups that are still mounted in the DOM. So if you call
     * `createPopup()` but later remove its container element (or an ancestor of
     * the container), then the `Popup` object will have been made invalid and
     * is therefore not included in the results.
     */
    getPopups(): Popup[];
    /**
     * Returns a list of all active {@link Inbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes inboxes that are still mounted in the DOM. So if you call
     * `createInbox()` but later remove its container element (or an ancestor of
     * the container), then the `Inbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getInboxes(): Inbox[];
    /**
     * Returns a list of all active {@link Chatbox} objects linked to this
     * session.
     *
     * @remarks
     * Only includes chatboxes that are still mounted in the DOM. So if you call
     * `createChatbox()` but later remove its container element (or an ancestor of
     * the container), then the `Chatbox` object will have been made invalid and
     * is therefore not included in the results.
     */
    getChatboxes(): Chatbox[];
    /**
     * Upload a generic file without any additional metadata.
     *
     * @remarks
     * This function does not send any message, it only uploads the file and returns a file token.
     * To send the file in a message, pass the file token in a {@link SendFileBlock} when calling {@link ConversationRef.send}.
     *
     * {@link https://talkjs.com/docs/Reference/Concepts/Message_Content/#sending-message-content | See the documentation} for more information about sending files in messages.
     *
     * If the file is a video, image, audio file, or voice recording, use one of the other functions like {@link uploadImage} instead.
     *
     * @param data The binary file data. Usually a {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File}.
     * @param metadata Information about the file
     * @returns A file token that can be used to send the file in a message.
     */
    uploadFile(data: Blob, metadata: GenericFileMetadata): Promise<FileToken>;
    /**
     * Upload an image with image-specific metadata.
     *
     * @remarks
     * This is a variant of {@link Session.uploadFile} used for images.
     *
     * @param data The binary image data. Usually a {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File}.
     * @param metadata Information about the image.
     * @returns A file token that can be used to send the image in a message.
     */
    uploadImage(data: Blob, metadata: ImageFileMetadata): Promise<FileToken>;
    /**
     * Upload a video with video-specific metadata.
     *
     * @remarks
     * This is a variant of {@link Session.uploadFile} used for videos.
     *
     * @param data The binary video data. Usually a {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File}.
     * @param metadata Information about the video.
     * @returns A file token that can be used to send the video in a message.
     */
    uploadVideo(data: Blob, metadata: VideoFileMetadata): Promise<FileToken>;
    /**
     * Upload an audio file with audio-specific metadata.
     *
     * @remarks
     * This is a variant of {@link Session.uploadFile} used for audio files.
     *
     * @param data The binary audio data. Usually a {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File}.
     * @param metadata Information about the audio file.
     * @returns A file token that can be used to send the audio file in a message.
     */
    uploadAudio(data: Blob, metadata: AudioFileMetadata): Promise<FileToken>;
    /**
     * Upload a voice recording with voice-specific metadata.
     *
     * @remarks
     * This is a variant of {@link Session.uploadFile} used for voice recordings.
     *
     * @param data The binary audio data. Usually a {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File}.
     * @param metadata Information about the voice recording.
     * @returns A file token that can be used to send the audio file in a message.
     */
    uploadVoice(data: Blob, metadata: VoiceRecordingFileMetadata): Promise<FileToken>;
}

/**
 * @public
 */
export declare interface SessionOptions {
    /** Your app's unique TalkJS ID. Get it from the "Settings" page of your dashboard. */
    appId: string;
    /**
     * A `User` object that identifies the currently active user.
     * The user is uniquely identified by their id; all other fields
     * (name, photo, etc) are overwritten in the TalkJS database each
     * time they change, unless the user has been created with the alternate
     * constructor. */
    me?: User;
    /**
     * The ID of the currently active user.
     *
     * This is an alternative to passing a `User` object to the `me` option.
     */
    userId?: string;
    /**
     * A token to authenticate the session with.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Authentication/ | See the how-to guide} on generating authentication tokens, and many examples in different programming languages.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#token-reference | See the reference documentation} for full details on the technical requirements for the JWT.
     */
    token?: string;
    /**
     * A function that fetches and returns a new authentication token from your server.
     * TalkJS calls this function whenever the current token is about to expire.
     * This callback is designed to work with any backend setup.
     *
     * TalkJS will not retry your `tokenFetcher` if the callback throws an error.
     * Your callback should implement its own retry functionality.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#refreshable-tokens | See the how-to guide} on refreshable authentication tokens, and many examples in different programming languages.
     */
    tokenFetcher?: () => string | Promise<string>;
    /**
     * Legacy alternative to JWT authentication.
     * A HMAC-SHA256 hash of the current user ID, signed with your TalkJS secret key.
     *
     * {@link https://talkjs.com/docs/Features/Security_Settings/Advanced_Authentication/#signature-based-verification-legacy | See the documentation} for examples of how to generate a signature in different programming languages.
     *
     * @deprecated This will keep being supported, but for new projects, use {@link SessionOptions.token} instead.
     * JWT authentication is recommended because signatures never expire, meaning there is no way to revoke access.
     */
    signature?: string;
}

/**
 * Parameters you can pass to {@link ConversationRef.set}.
 *
 * Properties that are `undefined` will not be changed.
 * To clear / reset a property to the default, pass `null`.
 *
 * @public
 */
export declare interface SetConversationParams {
    /**
     * The conversation subject to display in the chat header.
     * Default = no subject, list participant names instead.
     */
    subject?: string | null;
    /**
     * The URL for the conversation photo to display in the chat header.
     * Default = no photo, show a placeholder image.
     */
    photoUrl?: string | null;
    /**
     * System messages which are sent at the beginning of a conversation.
     * Default = no messages.
     */
    welcomeMessages?: string[] | null;
    /**
     * Custom metadata you have set on the conversation.
     * This value acts as a patch. Remove specific properties by setting them to `null`.
     * Default = no custom metadata
     */
    custom?: Record<string, string | null> | null;
    /**
     * Your access to the conversation.
     * Default = "ReadWrite" access.
     */
    access?: "Read" | "ReadWrite" | null;
    /**
     * Your notification settings.
     * Default = `true`
     */
    notify?: boolean | "MentionsOnly" | null;
}

/**
 * Parameters you can pass to {@link ParticipantRef.set} or {@link ParticipantRef.edit}.
 *
 * @remarks
 * Properties that are `undefined` will not be changed.
 * To clear / reset a property to the default, pass `null`.
 *
 * @public
 */
export declare interface SetParticipantParams {
    /**
     * The level of access the participant should have in the conversation.
     * Default = "ReadWrite" access.
     */
    access?: "ReadWrite" | "Read" | null;
    /**
     * When the participant should be notified about new messages in this conversation.
     * Default = `ReadWrite` access.
     *
     * @remarks
     * `false` means no notifications, `true` means notifications for all messages, and `"MentionsOnly"` means that the user will only be notified when they are mentioned with an `@`.
     */
    notify?: boolean | "MentionsOnly" | null;
}

/**
 * Parameters you can pass to {@link UserRef.set}.
 *
 * @remarks
 * Properties that are `undefined` will not be changed.
 * To clear / reset a property to the default, pass `null`.
 *
 * @public
 */
export declare interface SetUserParams {
    /**
     * The user's name which will be displayed on the TalkJS UI
     */
    name?: string;
    /**
     * Custom metadata you have set on the user.
     * This value acts as a patch. Remove specific properties by setting them to `null`.
     * Default = no custom metadata
     */
    custom?: Record<string, string | null> | null;
    /**
     * An {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}
     * Default = the locale selected on the dashboard
     */
    locale?: string;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar.
     * Default = no photo
     */
    photoUrl?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     * Default = the `default` role
     */
    role?: string | null;
    /**
     * The default message a person sees when starting a chat with this user.
     * Default = no welcome message
     */
    welcomeMessage?: string | null;
    /**
     * A single email address or an array of email addresses associated with the user.
     * Default = no email addresses
     */
    email?: string | string[] | null;
    /**
     * A single phone number or an array of phone numbers associated with the user.
     * Default = no phone numbers
     */
    phone?: string | string[] | null;
    /**
     * An object of push registration tokens to use when notifying this user.
     *
     * Keys in the object have the format `'provider:token_id'`,
     * where `provider` is either `"fcm"` for Android (Firebase Cloud Messaging),
     * or `"apns"` for iOS (Apple Push Notification Service).
     *
     * The value for each key can either be `true` to register the device for push notifications, or `null` to unregister that device.
     *
     * Setting pushTokens to null unregisters all the previously registered devices.
     *
     * Default = no push tokens
     */
    pushTokens?: Record<string, true | null> | null;
}

/**
 * Allows you to filter conversations down to a specific subset.
 *
 * @remarks
 * Use with {@link Inbox.setFeedFilter} or pass {@link InboxOptions.feedFilter} to
 * {@link Session.createInbox}. For example, to hide read conversations, use:
 *
 * `inbox.setFeedFilter({ hasUnreadMessages: true })`.
 *
 * To show everything (ie to disable the filter), use an empty object:
 *
 * `inbox.setFeedFilter({})`.
 *
 * @public
 */
export declare interface SimpleConversationPredicate {
    /**
     * Only select conversations that the current user as specific access to.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string (one of `"ReadWrite"`, `"Read"` or `"None"`) or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to remove conversations that the user has no access to anymore, do:
     * { access: ["!=", "None"] }
     * ```
     */
    access?: FieldPredicate<ConversationAccessLevel>;
    /**
     * Only select conversations that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom conversation data that you set (by passing
     * `custom` to {@link ConversationBuilder.setAttributes}). It is not necessary for all
     * conversations to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your conversations:
     *
     * ```js
     * // only show conversations that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // only show conversations of category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // only show conversations either category "shoes" or "sandals"
     * { custom: { category: ["oneOf", ["shoes", "sandals"] ] } }
     *
     * // only show conversations about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Set this field to only select conversations that have, or don't have any, unread messages.
     */
    hasUnreadMessages?: boolean;
    /**
     * Only select conversations that have the subject set to particular values.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * The operand must be either a string or an array of strings (for the `oneOf` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have "Black leather boots" or "Hair Wax 5 Gallons" as the subject
     * { subject: ["oneOf", ["Black leather boots", "Hair Wax 5 Gallons"]] }
     * ```
     */
    subject?: FieldPredicate<string | null>;
    /**
     * Only select conversations that have the last message sent in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have the last message sent after the UNIX timestamp 1679298371586
     * { lastMessageTs: [">", 1679298371586] }
     * ```
     */
    lastMessageTs?: NumberPredicate;
    /**
     * Only select conversations that have been created in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the conversations that have been created after the UNIX timestamp 1679298371586
     * { createdAt: [">", 1679298371586] }
     * ```
     */
    createdAt?: NumberPredicate;
}

/**
 * Lets you show only specific messages in the chat panel of a Chatbox, Inbox or Popup.
 *
 * @remarks
 * Used in methods like {@link Chatbox.setMessageFilter}. For example, to hide all system messages (eg only show user messages), do:
 *
 * `chatbox.setMessageFilter({type: ["==", "UserMessage"]})`
 *
 * To show all messages (ie disable the filter), just pass an empty object:
 *
 * `chatbox.setMessageFilter({})`
 *
 * @public
 */
export declare interface SimpleMessagePredicate {
    /**
     * Only show messages that are sent by a sender that has all of the given properties
     *
     * For example:
     *
     * ```js
     * // Only show messages sent by users with the role of 'admin' and if the user ID is 1.
     * {sender: {role: ["==", "admin"], id: ["==", "1"]}}
     * ```
     */
    sender?: SenderPredicate;
    /**
     * Only show messages of a given type, for example:
     *
     * ```js
     * {type: ["==", "SystemMessage"]}
     * ```
     *
     */
    type?: FieldPredicate<"UserMessage" | "SystemMessage">;
    /**
     * Only show messages that were sent by users (web), through the REST API (rest), via
     * reply-to-email (email) or via the import REST API (import).
     *
     * For example:
     *
     * ```js
     * // Don't show messages that were sent via the REST API
     * { origin: ["!=", "rest"] }
     * ```
     *
     */
    origin?: FieldPredicate<"web" | "rest" | "email" | "import">;
    /**
     * Only select messages that have particular custom fields set to particular values.
     *
     * @remarks
     * Every key must correspond to a key in the custom message data that you have set. It is not necessary for all
     * messages to have these keys.
     *
     * Each value must be one of the following:
     *
     * A string, equal to `"exists"` or `"!exists"`
     *
     * A 2-element array of `[operator, operand]` structure.  The operand must be either a
     * string or an array of strings (for the `oneOf` operators). Valid operators are:
     * `"=="`, `"!="`, `"oneOf"`, and `"!oneOf"`.
     *
     * Examples, assuming you have set a `category` custom field on your messages:
     *
     * ```js
     * // Only show messages that have no category set:
     * { custom: { category: "!exists" } }
     *
     * // Only show messages of that have the category "shoes"
     * { custom: { category: ["==", "shoes"] } }
     *
     * // Only show messages that have the 'topic' either "inquiry" or "reservation"
     * { custom: { topic: ["oneOf", ["inquiry", "reservation"] ] } }
     *
     * // Only show messages about shoes that are marked visible.
     * // this assumes you also have a custom field called `visibility`
     * { custom: { category: ["==", "shoes"], visibility: ["==", "visible" ] } }
     * ```
     */
    custom?: {
        [key: string]: CustomFieldPredicate;
    };
    /**
     * Only select messags that have been sent in a particular time interval.
     *
     * Must be an 2-element array of `[operator, operand]` structure. Valid operators are:
     * `">"`, `"<"`, `">="`, `"<="`, `"between"`, and `"!between"`.
     *
     * The operand must be either a number or a 2-element array of numbers (for the `between` operators).
     *
     * Example:
     * ```js
     * // to show only the messages that have been sent after the UNIX timestamp 1679298371586
     * { createdAt: [">", 1679298371586] }
     * ```
     */
    createdAt?: NumberPredicate;
}

/**
 * A subscription to an event
 * @public
 */
export declare interface Subscription {
    /**
     * Stop receiving events for this subscription
     */
    unsubscribe(): void;
}

/**
 * TalkJS Error class, inherits from the global Error class.
 *
 * @remarks
 * TalkJS methods may throw (or reject promises with) instances of this class
 * if specific catchable information can be provided through the `code` property.
 *
 * @public
 */
export declare class TalkError extends Error {
    /**
     * Machine-readable error code
     */
    code: ErrorCode;
    /**
     * Human-readable error message
     */
    message: string;
}

/**
 * A block of formatted text in a message's content.
 *
 * @remarks
 * Each TextBlock is a tree of {@link TextNode} children describing the structure of some formatted text.
 * Each child is either a plain text string, or a `node` representing some text with additional formatting.
 *
 * For example, if the user typed:
 *
 * > *This first bit* is bold, and *_the second bit_* is bold and italics
 *
 * Then this would become a Text Block with the structure:
 *
 * ```
 * {
 *   type: "text",
 *   children: [
 *      {
 *       type: "text",
 *       children: [
 *         { type: "bold", children: ["This first bit"] },
 *         " is bold, and ",
 *         {
 *           children: [
 *             { type: "italic", children: ["the second bit"] }
 *           ],
 *           type: "bold",
 *         },
 *         " is bold and italics",
 *       ],
 *     },
 *   ],
 * }
 * ```
 *
 * Rather than relying the automatic message parsing, you can also specify the `TextBlock` directly using {@link ConversationRef.send} with {@link SendMessageParams}.
 *
 * @public
 */
export declare interface TextBlock {
    type: "text";
    children: TextNode[];
}

/**
 * Any node that can exist inside a {@link TextBlock}.
 *
 * @remarks
 * The simplest `TextNode` is a plain text string.
 * Using "hello" as an example message, the `TextBlock` would be:
 *
 * ```typescript
 * {
 *   type: 'text';
 *   children: ['hello'];
 * }
 * ```
 *
 * Other than plain text, there are many different kinds of node which render some text in a specific way or with certain formatting.
 *
 * ```
 * type TextNode =
 *     | string
 *     | MarkupNode
 *     | BulletListNode
 *     | BulletPointNode
 *     | CodeSpanNode
 *     | LinkNode
 *     | AutoLinkNode
 *     | ActionLinkNode
 *     | ActionButtonNode
 *     | CustomEmojiNode
 *     | MentionNode;
 * ```
 *
 * If the text node is not a plain string, it will have a `type` field indicating what kind of node it is, and either a property `text: string` or a property `children: TextNode[]`.
 * This will be true for all nodes added in the future as well.
 *
 * @public
 */
export declare type TextNode = string | MarkupNode | BulletListNode | BulletPointNode | CodeSpanNode | LinkNode | AutoLinkNode | ActionLinkNode | ActionButtonNode | CustomEmojiNode | MentionNode;

/**
 * @public
 */
export declare interface ThemeOptions {
    /**
     * The name of the theme to use in this widget
     * If no theme name is given, TalkJS will use the theme set in the user's role,
     * falling back to the default theme if the user has no role.
     */
    name?: string;
    /**
     * A map of values that will be available to your theme under the `theme.custom` namespace.
     * The values can be anything that can be JSON-serialized.
     * String and numeric values will also be made available as CSS custom properties in themes, available as `var(--theme-<key>)`. where `<key>` is the value's key in the object.
     */
    custom?: {
        [key: string]: JsonSerializable;
    };
}

/**
 * @public
 * Used to configure supported third-party integrations with TalkJS. See
 * {@link https://talkjs.com/docs/Features/Customizations/Third_Party_Integrations.html | third party integrations }
 *
 */
export declare interface ThirdPartyOptions {
    fullstory?: FullStoryOptions;
}

/**
 * @public
 * This event is triggered when the user toggles real-time message translation using the built-in toggle.
 */
export declare interface TranslationToggledEvent {
    /**
     * Boolean indicating if translation is enabled or not
     */
    isEnabled: boolean;
    /**
     * Conversation for which translation has been toggled
     */
    conversation: ConversationData;
}

/**
 * @public
 * @hidden
 */
export declare interface UIBox {
    /**
     * The conversation currently shown in the UI.
     *
     * @remarks
     * This field is `null` when the UI does not currently show a conversation (eg
     * because `null` was passed to {@link UIBox.select} or the selected
     * conversation could not be found).
     */
    readonly currentConversation: ConversationData | null;
    /**
     * Whether the object is active and in a valid state.
     *
     * @remarks
     * When false, calling methods on this instance will throw errors.
     *
     * This field is false when {@link UIBox.destroy} has been called in the past.
     * It is also false if {@link Session.destroy} has been called, because
     * destroying a session destroys all its UI widgets.
     *
     * Finally, an instance may also be considered if its previously mounted
     * iframe has been removed from the DOM by some external library.
     *
     * Once this instance has been destroyed, you cannot revive it. Instead,
     * create a new instance.
     */
    readonly isAlive: boolean;
    /**
     * Switches the active conversation.
     *
     * @remarks
     * `conversation` can be either a {@link ConversationBuilder} object or a TalkJS
     * conversation id. Passing `null` means that the conversation will be de-selected in the UI and the message list will disappear.
     * Passing `undefined` means that the last conversation (or "no chats yet" page if there are no other conversations) will be rendered in the message list component.
     *
     * @returns A promise that resolves once the new conversation has been selected.
     */
    select(conversation: string | Conversation | ConversationBuilder | ConversationRef | null | undefined, params?: SelectConversationOptions): Promise<void>;
    /**
     * Encapsulates the message entry field tied to the currently selected conversation.
     */
    messageField: MessageField;
    /**
     * Upload a file attachment to the currently active conversation.
     *
     * @remarks
     * The behaviour of this method is similar to if the user clicked the attachment button, in that the confirmation
     * dialog is shown to the user.
     *
     * Ensure that the {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File} object's name property has
     * an appropriate file extension.
     *
     * @param file - The {@link https://developer.mozilla.org/en-US/docs/Web/API/File | File} object to be uploaded.
     */
    sendFile(file: File): Promise<void>;
    /**
     * Send the user's current location to the currently active conversation.
     *
     * @remarks
     * The behaviour of this method is identical to the user clicking the location button in message field i.e the confirmation
     * dialog is shown.
     *
     * Note: If the user had not previously granted location access to your website, calling this method will
     * trigger the browser's popup asking them for permission to access their location. The user's location will only be
     * shared if they allow.
     */
    sendLocation(): Promise<void>;
    /**
     * Listens for an event.
     *
     * @remarks
     * Triggers when the user sends a message using the TalkJS UI
     *
     * @deprecated Please use {@link Chatbox.onSendMessage} instead.
     */
    on(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere inside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onFocus} instead.
     */
    on(eventType: "focus", handler: () => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     *
     * @deprecated Please use {@link Chatbox.onBlur} instead.
     */
    on(eventType: "blur", handler: () => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * Triggers when the user toggles translation in a conversation
     * @deprecated Please use {@link Chatbox.onTranslationToggled} instead.
     */
    on(eventType: "translationToggled", handler: (event: TranslationToggledEvent) => void): void;
    /**
     * Listens for an event.
     *
     * @remarks
     * This event is only emitted when {@link ChatboxOptions.captureKeyboardEvents} is enabled. In
     * that case, it is emitted for every keypress, including regular letters typed into text fields.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the message field, the
     * search box, or adjacent buttons). When this is the case, keypresses are likely to cause changes
     * inside the chat UI. We recommend that you discard these events except when implementing global
     * shortcuts that should take effect regardless of whether the user is typing a message or
     * otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, TalkJS does not handle special multi-key shortcuts other than those provided
     * by the user's device (eg ctrl+v for paste). This means that it is usually safe to assign
     * special behavior to unused keyboard shortcuts with one or more modifier keys (like alt, shift
     * or ctrl), even when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.on("keyup", event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *   if(!event.isInputFocused && event.key === "1") {
     *     // let the 1 key switch to our app's main panel, except if the user is typing
     *     myApp.selectMainPanel();
     *   }
     *   if(event.ctrlKey && event.key === "q") {
     *     // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *     myApp.quit();
     *   }
     * });
     * ```
     *
     * @deprecated Please use {@link Chatbox.onKeyup} instead.
     */
    on(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("sendMessage")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onSendMessage} instead.
     */
    off(eventType: "sendMessage", handler: (event: SendMessageEvent) => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("focus")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onFocus} instead.
     */
    off(eventType: "focus", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("blur")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onBlur} instead.
     */
    off(eventType: "blur", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     *
     * @param eventType -
     * @param handler - The handler function must be the same handler function that was passed to `on("translationToggled")`
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onTranslationToggled} instead.
     */
    off(eventType: "translationToggled", handler: () => void): void;
    /**
     * Stops emitting events registered with {@link UIBox.on}.
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Chatbox.onKeyup} instead.
     */
    off(eventType: "keyup", handler: (event: KeyEvent) => void): void;
    /**
     * @hidden
     */
    onCustomMessageAction(handler: (event: MessageActionEvent) => void): Subscription;
    /**
     * Triggers when a user launches a custom action on a message within the TalkJS UI.
     *
     * @remarks
     * To set up a custom action, you can either create it on the "Chat UI" page in your dashboard,
     * add an action button to your messages,
     * or add an action button to the `UserMessage`, `SystemMessage`,
     * or `MessageBody` components of your theme in the Theme Editor,
     * which you can access from the "Themes" page in your dashboard.
     * If an action is allowed on a particular message, it'll show up in that message's action menu.
     * The name you specify when setting up the action, is also the name you should pass in here (case sensitive).
     * The event you get contains information about the message on which the action was called, including its ID, so you can look it up later via our REST API.
     * @param action - Optional. The action you want to listen for. Omit to listen for any action.
     * @param handler - The handler to be called
     * @returns A subscription you can use to unsubscribe.
     */
    onCustomMessageAction(action: string, handler: (event: MessageActionEvent) => void): Subscription;
    /**
     * @hidden
     */
    onCustomConversationAction(handler: (event: ConversationActionEvent) => void): Subscription;
    /**
     * Triggers when a user launches a custom action on a conversation within the
     * TalkJS UI.
     *
     * @remarks
     * To set up a custom action, you can either create it on the "Chat UI" page in
     * your dashboard or add an action button to the `ChatHeader`, `MessageField`,
     * `ConversationListHeader` or `ConversationListItem` components of your theme
     * in the Theme Editor, which you can access from the "Themes" page in your dashboard.
     * If an action is allowed on a particular conversation, it'll show up in that
     * conversation's action menu. The name you specify when setting up the
     * action, is also the name you should pass in here (case sensitive). The
     * event you get contains information about the conversation on which the
     * action was called, including its ID, so you can look it up later via our
     * REST API.
     * @param action - Optional. The action you want to listen for. Omit to listen for any action.
     * @param handler - The handler to be called
     * @returns A subscription you can use to unsubscribe.
     */
    onCustomConversationAction(action: string, handler: (event: ConversationActionEvent) => void): Subscription;
    /**
     * Triggers when the user sends a message using the TalkJS UI
     */
    onSendMessage(handler: (event: SendMessageEvent) => void): Subscription;
    /**
     * Triggers when the user clicks on the "Leave conversation" action
     *
     * @remarks
     * This event triggers *before* the user actually leaves the conversation. You
     * can call `event.preventDefault()` to disallow the user from actually
     * leaving.
     *
     * This event only triggers when the user performs a Leave action from inside
     * the chat UI. Notably, when a user leaves the conversation through other
     * means (for example, they're removed from the conversation using the REST
     * API), this event does not trigger.
     */
    onLeaveConversation(handler: (event: LeaveConversationEvent) => void): Subscription;
    /**
     * Triggers when the user clicks on the "Mark as unread" action
     *
     * @remarks
     * This event triggers *before* the user actually marks the conversation as
     * unread. You can call `event.preventDefault()` to disallow the user from
     * actually marking it as unread.
     *
     * This event only triggers when the user performs a "Mark as unread" action
     * from inside the chat UI. Notably, when a user marks the conversation as
     * unread through other means (for example, via the REST API), this event does
     * not trigger.
     */
    onMarkConversationAsUnread(handler: (event: MarkConversationAsUnreadEvent) => void): Subscription;
    /**
     * Triggers when the chat UI is focussed.
     */
    onFocus(handler: () => void): Subscription;
    /**
     * Triggers when focus moves out of the chat UI.
     *
     * @remarks
     * Emits an event when the user clicks/taps anywhere outside the chat UI.
     */
    onBlur(handler: () => void): Subscription;
    /**
     * Triggers when the user toggles message translation in the TalkJS UI.
     */
    onTranslationToggled(handler: (event: TranslationToggledEvent) => void): Subscription;
    /**
     * Triggers a {@link KeyEvent} when the user releases a key.
     *
     * @remarks
     * This event is only emitted when
     * {@link ChatboxOptions.captureKeyboardEvents} is enabled. In that case, it
     * is emitted for every keypress, including regular letters typed into text
     * fields.
     *
     * Note that there's a notorious system limitation on macOS: `metaKey` is not
     * set in keyup events when hitting keystrokes (eg Cmd+p). Consider using
     * {@link UIBox.onKeydown} if you need to support `Cmd`.
     *
     * `event.isInputFocused` is true when a TalkJS input area is focused (eg the
     * message field, the search box, or adjacent buttons). When this is the case,
     * keypresses are likely to cause changes inside the chat UI. We recommend
     * that you discard these events except when implementing global shortcuts
     * that should take effect regardless of whether the user is typing a message
     * or otherwise interacting with the chat UI using the keyboard.
     *
     * Note: by design, the TalkJS UI does not handle special multi-key shortcuts
     * other than those provided by the user's device (eg ctrl+v for paste). This
     * means that it is usually safe to assign special behavior to unused keyboard
     * shortcuts with one or more modifier keys (like alt, shift or ctrl), even
     * when `isInputFocused` is true.
     *
     * All other event fields are the same as the corresponding fields in the
     * browser's
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent | KeyboardEvent}.
     *
     * @example
     * ```ts
     * myChatbox.onKeyup(event => {
     *   if(event.shiftKey || event.altKey || event.metaKey) {
     *     return;
     *   }
     *
     *   // let the 1 key switch to our app's main panel, except if the user is typing
     *   if(!event.isInputFocused && event.key === "1") {
     *     myApp.selectMainPanel();
     *   }
     *
     *   // quit if the user hits ctrl+q, irrespective of whether they're typing.
     *   if(event.ctrlKey && event.key === "q") {
     *     myApp.quit();
     *   }
     * });
     * ```
     */
    onKeyup(handler: (event: KeyEvent) => void): Subscription;
    /**
     * Triggers a {@link KeyEvent} when the user presses a key.
     *
     * @remarks
     * See {@link UIBox.onKeyup} for more details.
     */
    onKeydown(handler: (event: KeyEvent) => void): Subscription;
    /**
     * Puts custom HTML just above the message field.
     *
     * @remarks
     * Using HTML Panels, you can extend TalkJS UIs to have anything from credit card payments to lead
     * collection forms, or, for instance, to show the product details of a marketplace transaction
     * between your users. See our
     * {@link https://talkjs.com/docs/Features/Customizations/HTML_Panels.html | HTMLPanels documentation}
     * for more info.
     */
    createHtmlPanel(options: HtmlPanelOptions): Promise<HtmlPanel>;
    /**
     * Sets metadata for the current session.
     *
     * @remarks
     * <b>Note:</b> If you want to mount UI that is already hidden, set
     *  {@link ChatboxOptions.presence | presence when creating the UI} or call
     * `setPresence({ visible: false })` before calling {@link UIBox.mount}.
     *
     * Also, important to note, is that the {@link Popup} internally calls this method
     * when a user opens or closes it. `visible` is set to `true` or `false` respectively.
     *
     */
    setPresence(presence: UserPresence): void;
    /**
     * Destroys the component and removes it from the DOM
     *
     * @remarks
     * Destroys the component, removes it from the DOM and removes all event listeners it has running. Call this before removing
     * the the component container from the DOM.
     */
    destroy(): void;
    /**
     * Toggles desktop notifications
     *
     * @remarks
     * This method will keep being supported, but for new projects,
     * we recommend that you use {@link Session.setDesktopNotificationEnabled}.
     *
     * Sets desktop notification on or off. Has the same effect as toggling the
     * "Desktop notification" toggle in the TalkJS Inbox UI. Use this function to replicate that
     * toggle elsewhere in your UI if you're using TalkJS in a mode that doesn't show this toggle.
     *
     * @deprecated Please use {@link Session.setDesktopNotificationEnabled} instead.
     */
    toggleDesktopNotifications(isEnabled: boolean): void;
    /**
     * Used to control which messages are shown in the message list
     *
     * @remarks
     * Lets you filter messages depending on a type, origin or custom message attributes.
     *
     * <b>Note</b>: Messages are only filtered in the message list. The inbox UI's conversation feed will
     * always show the last message sent to the conversation, regardless of the message filter set.
     *
     * See {@link MessagePredicate} for all available options.
     *
     * @example
     * ```ts
     * // only show messages sent by users with role "admin"
     * chatbox.setMessageFilter({
     *   sender: {
     *     role: ["==", "admin"],
     *   }
     * });
     * ```
     *
     * @param filter - A predicate object that controls which messages are shown.
     */
    setMessageFilter(filter: MessagePredicate): void;
    /**
     * Enable or disable translation for a conversation.
     *
     * @param conversation - The conversation for which this should be set. If not specified, the setting will be applied to the currently selected conversation.
     * @param enabled - Whether translation should be enabled
     */
    setTranslationEnabledForConversation(conversation: string | ConversationBuilder, enabled: boolean): void;
    /**
     * Enable/disable translation by default.
     *
     * @remarks
     * This setting is applied to any conversation for which you haven't set a specific value.
     *
     * @param enabled - Whether conversations should be translated by default or not. Pass "auto" to
     *                  enable translation for conversations with users with different locales.
     */
    setTranslationEnabledDefault(enabled: boolean | "auto"): void;
    /**
     * Highlights certain words in messages
     *
     * @remarks
     * The TalkJS search feature includes the ability to highlight certain words in messages. Call
     * this method to highlight certain words without having the user invoke the search feature.
     * Call again with an empty array to disable highlighting.
     *
     * Note: like the search feature, this option only works on the Growth plan and up.
     *
     * Also see {@link ChatboxOptions.highlightedWords}
     */
    setHighlightedWords(words: string[]): void;
}

/**
 * @public
 * Used as part of {@link Unreads.on}.
 */
export declare interface UnreadConversation {
    /**
     * The {@link ConversationData} of the unread conversation.
     *
     * @remarks
     * Always identical to `lastMessage.conversation`, which is maintained for
     * compatibility reasons.
     */
    conversation: ConversationData;
    /**
     * Contains the last {@link Message} for this conversation.
     */
    lastMessage: Message;
    /**
     *
     * The number of unread messages in this conversation.
     *
     * Note: Conversations with last activity before 15 June 2023 will have `unreadMessageCount` value set to 0 on initial load. It will be properly set after the next refresh
     */
    unreadMessageCount: number;
}

/**
 * This object can notify you when the amount of unread conversations changes.
 * You can't instantiate it - instead, get an instance via {@link Session.unreads}.
 *
 * @public
 */
export declare interface Unreads {
    /**
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * @remarks
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     *
     * Related methods: {@link Unreads.off}
     *
     * @deprecated Please use {@link Unreads.onChange} instead.
     */
    on(eventType: "change", handler: (unreadConversations: UnreadConversation[]) => void): void;
    /**
     * Call this with the same `eventType` and `handler` that you used for `on` to
     * stop receiving events.
     *
     * @remarks
     * Related methods: {@link Unreads.on}
     *
     * @deprecated Please use the {@link Subscription.unsubscribe} method on the object returned by {@link Unreads.onChange} instead.
     */
    off(eventType: "change", handler: (unreadConversations: UnreadConversation[]) => void): void;
    /**
     * Triggered when the list of unread conversations changes.
     *
     * @remarks
     * A "change" event is fired on startup right after TalkJS loads, as well as every time the
     * amount of unread conversations changed. The `handler` is invoked with an array of objects with
     * limited information about each conversation, see {@link UnreadConversation}.
     *
     * Note that conversations where the user is a {@link https://talkjs.com/docs/Reference/Concepts/Guests/ | guest}
     * do not keep track of unread messages. This is only done for users who are added as participants.
     */
    onChange(handler: (unreadConversations: UnreadConversation[]) => void): Subscription;
}

/**
 * The state of a subscription after you have manually unsubscribed
 *
 * @public
 */
export declare interface UnsubscribedState {
    type: "unsubscribed";
}

/**
 * A user of your app. TalkJS uses the `id` to uniquely identify this user.
 * All other fields of a User are allowed to vary over time and the TalkJS database will update its fields accordingly.
 * @public
 */
export declare class User {
    /**
     * The unique ID which is used to identify the user in TalkJS
     */
    readonly id: string;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    readonly name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     */
    readonly email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     */
    readonly phone?: string | Array<string> | null;
    /**
     * The default message a user sees when starting a chat with that person
     */
    readonly welcomeMessage?: string | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     */
    readonly photoUrl?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    readonly role?: string | null;
    /**
     * @deprecated Please use {@link User.role} instead.
     */
    readonly configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     */
    readonly custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     *
     */
    readonly availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}.
     */
    readonly locale?: string | null;
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Use this constructor to create or update user data.
     * The user is {@link https://talkjs.com/docs/Features/Security_Settings/Browser_Synchronization.html | synchronized}
     * with the TalkJS backend if they are the current user in a session.
     * If they are not the current user, and they are part of an existing conversation,
     * they will be synchronized when the UI is mounted.
     *
     * The fields `id`, `name` and `email` are required.
     * A warning will be emitted if `role` is not specified.
     *
     * Set `email` to `null` if you want to use TalkJS without email fallback.
     */
    constructor(options: UserOptions);
    /**
     * Create a TalkJS User
     *
     * @remarks
     * Only use this constructor if you're sure
     * that a user by the given `id` already exists in TalkJS (for instance, because you
     * synchronized it via the REST API). Otherwise use the `new User(options: object):` constructor instead.
     */
    constructor(id: string | number);
}

/**
 * The state of a user subscription when it is actively listening for changes
 *
 * @public
 */
export declare interface UserActiveState {
    type: "active";
    /**
     * The most recently received snapshot for the user, or `null` if the user does not exist yet.
     */
    latestSnapshot: UserSnapshot | null;
}

/**
 * @public
 */
export declare interface UserOptions {
    /**
     * The unqiue ID which is used to identify the user in TalkJS
     */
    id: string | number;
    /**
     * The User's name which will be displayed on the TalkJS UI
     */
    name: string;
    /**
     * One or more email address belonging to the User. The email addresses will be used for {@link https://talkjs.com/docs/Features/Notifications/Email_Notifications/index.html | Email Notifications}
     * if they are enabled.
     * @remarks
     * Set to `null` to delete the existing value(s) (if any). When omitted or `undefined`, the existing value(s) remain unchanged.
     */
    email?: string | Array<string> | null;
    /**
     * One or more phone numbers belonging to the User. The phone number will be used for {@link https://talkjs.com/docs/Features/Notifications/SMS_Notifications.html | SMS Notifications }
     * (this feature requires standard plan and up).
     * @remarks
     * Set to `null` to delete the existing value(s) (if any). When omitted or `undefined`, the existing value(s) remain unchanged.
     */
    phone?: string | Array<string> | null;
    /**
     * An optional URL to a photo which will be displayed as the user's avatar
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    photoUrl?: string | null;
    /**
     * The default message a user sees when starting a chat with that person
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    welcomeMessage?: string | null;
    /**
     * TalkJS supports multiple sets of settings, called "roles". These allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    role?: string | null;
    /**
     * @deprecated Please use {@link UserOptions.role} instead.
     */
    configuration?: string | null;
    /**
     * Allows you to set custom metadata for the User
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: {
        [name: string]: string | null;
    } | null;
    /**
     * Availability acts similarly to {@link User.welcomeMessage} but appears as a {@link https://talkjs.com/docs/Reference/Concepts/System_Messages.html | system message}.
     *
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     *
     * @deprecated Please use {@link Conversation.welcomeMessages} instead.
     */
    availabilityText?: string | null;
    /**
     * The locale field expects an {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * See the {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | localization documentation}.
     *
     * @remarks
     * Set to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    locale?: string | null;
}

/**
 * @public
 */
export declare interface UserPresence {
    /**
     * Manually sets the information about the visibility of TalkJS.
     * This is useful when TalkJS is hidden with CSS. TalkJS will assume that UIs
     * marked `visible: false` cannot be seen, and thus messages arriving on this UI will
     * not be marked as read until you set `visible` to true again.
     * @remarks
     * When omitted or `undefined`, the existing value remains unchanged.
     */
    visible?: boolean;
    /**
     * This is an additional parameter to store the custom fields that you
     * may want to use in the REST API call.
     * @remarks
     * Set any property to `null` to delete the existing value (if any). When omitted or `undefined`, the existing value remains unchanged.
     */
    custom?: CustomData;
}

/**
 * References the user with a given user ID.
 *
 * @remarks
 * Used in all Realtime API operations affecting that user, such as creating the user, fetching or updating user data, or adding a user to a conversation.
 * Created via {@link Session.user}.
 *
 * @public
 */
export declare interface UserRef {
    /**
     * The ID of the referenced user.
     *
     * @remarks
     * Immutable: if you want to reference a different user, get a new UserRef instead.
     */
    readonly id: string;
    /**
     * Fetches a snapshot of the user.
     *
     * @remarks
     * This contains all of a user's public information.
     * Fetching a user snapshot doesn't require any permissions. You can read the public information of any user.
     * Private information, such as email addresses and phone numbers, aren't included in the response.
     *
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#automatic-batching | Automatic Batching} and {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#cached-fetch | Cached Fetch}
     *
     * @returns A snapshot of the user's public attributes, or null if the user doesn't exist.
     */
    get(): Promise<UserSnapshot | null>;
    /**
     * Sets properties of this user. The user is created if a user with this ID doesn't already exist.
     *
     * @remarks
     * `name` is required when creating a user. The promise will reject if you don't provide a `name` and the user does not exist yet.
     *
     * @returns A promise that resolves when the operation completes. The promise will reject if the request is invalid or if client-side user syncing is disabled.
     */
    set(params: SetUserParams): Promise<void>;
    /**
     * Creates a user with this ID, or does nothing if a user with this ID already exists.
     *
     * @remarks
     * If the user already exists, this operation is still considered successful and the promise will still resolve.
     *
     * @returns A promise that resolves when the operation completes. The promise will reject if client-side user syncing is disabled and the user does not already exist.
     */
    createIfNotExists(params: CreateUserParams): Promise<void>;
    /**
     * Subscribe to this user's state.
     *
     * @remarks
     * Whenever `Subscription.state.type` is "active" and the user is created or their attributes change, `onSnapshot` will fire and `Subscription.state.latestSnapshot` will be updated.
     *
     * Supports {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#subscription-sharing | Subscription Sharing} and {@link https://talkjs.com/docs/Reference/JavaScript_Chat_SDK/Realtime_API/#debounced-unsubscribe | Debounced Unsubscribe}
     *
     * @returns A subscription to the user
     */
    subscribe(onSnapshot?: (event: UserSnapshot | null) => void): UserSubscription;
}

/**
 * A snapshot of a user's attributes at a given moment in time.
 *
 * @remarks
 * Users also have private information, such as email addresses and phone numbers, but these are only exposed on the {@link https://talkjs.com/docs/Reference/REST_API/Getting_Started/Introduction/ | REST API}.
 *
 * Snapshots are immutable and we try to reuse them when possible. You should only re-render your UI when `oldSnapshot !== newSnapshot`.
 *
 * @public
 */
export declare interface UserSnapshot {
    /**
     * The unique ID that is used to identify the user in TalkJS
     */
    id: string;
    /**
     * The user's name, which is displayed on the TalkJS UI
     */
    name: string;
    /**
     * Custom metadata you have set on the user
     */
    custom: Record<string, string>;
    /**
     * An {@link https://www.w3.org/International/articles/language-tags/ | IETF language tag}.
     * For more information, see: {@link https://talkjs.com/docs/Features/Language_Support/Localization.html | Localization}.
     *
     * When `locale` is null, the app's default locale will be used
     */
    locale: string | null;
    /**
     * An optional URL to a photo that is displayed as the user's avatar
     */
    photoUrl: string | null;
    /**
     * TalkJS supports multiple sets of settings for users, called "roles". Roles allow you to change the behavior of TalkJS for different users.
     * You have full control over which user gets which configuration.
     */
    role: string;
    /**
     * The default message a person sees when starting a chat with this user
     */
    welcomeMessage: string | null;
}

/**
 * A subscription to a specific user
 *
 * @remarks
 * Get a UserSubscription by calling {@link UserRef.subscribe}
 *
 * @public
 */
export declare interface UserSubscription {
    /**
     * The current state of the subscription
     *
     * @remarks
     * An object with the following fields:
     *
     * `type` is one of "pending", "active", "unsubscribed", or "error".
     *
     * When `type` is "active", includes `latestSnapshot: UserSnapshot | null`. It is the current state of the user, or null if they don't exist.
     *
     * When `type` is "error", includes the `error: Error` field. It is a JS `Error` object explaining what caused the subscription to be terminated.
     */
    state: PendingState | UserActiveState | UnsubscribedState | ErrorState;
    /**
     * Resolves when the subscription starts receiving updates from the server.
     */
    connected: Promise<UserActiveState>;
    /**
     * Resolves when the subscription permanently stops receiving updates from the server.
     *
     * @remarks
     * This is either because you unsubscribed or because the subscription encountered an unrecoverable error.
     */
    terminated: Promise<UnsubscribedState | ErrorState>;
    /**
     * Unsubscribe from this resource and stop receiving updates.
     *
     * @remarks
     * If the subscription is already in the "unsubscribed" or "error" state, this is a no-op.
     */
    unsubscribe(): void;
}

/**
 * A FileBlock variant for a video attachment, with additional video-specific metadata.
 *
 * @remarks
 * You can identify this variant by checking for `subtype: "video"`.
 *
 * Includes metadata about the height and width of the video in pixels, and the duration of the video in seconds, where available.
 *
 * Videos that you upload with the TalkJS UI will include the dimensions and duration as long as the sender's browser can preview the file.
 * Videos that you upload with the REST API or {@link Session.uploadVideo} will include this metadata if you specified it when uploading.
 * Videos attached in a reply to an email notification will not include any metadata.
 *
 * @public
 */
export declare interface VideoBlock {
    type: "file";
    subtype: "video";
    /**
     * An encoded identifier for this file. Use in {@link SendFileBlock} to send this video in another message.
     */
    fileToken: FileToken;
    /**
     * The URL where you can fetch the file.
     */
    url: string;
    /**
     * The size of the file in bytes.
     */
    size: number;
    /**
     * The name of the video file, including file extension.
     */
    filename: string;
    /**
     * The width of the video in pixels, if known.
     */
    width?: number;
    /**
     * The height of the video in pixels, if known.
     */
    height?: number;
    /**
     * The duration of the video in seconds, if known.
     */
    duration?: number;
}

export declare interface VideoFileMetadata {
    /**
     * The name of the file including extension.
     */
    filename: string;
    /**
     * The width of the video in pixels, if known.
     */
    width?: number;
    /**
     * The height of the video in pixels, if known.
     */
    height?: number;
    /**
     * The duration of the video in seconds, if known.
     */
    duration?: number;
}

/**
 * A FileBlock variant for a voice recording attachment, with additional voice-recording-specific metadata.
 *
 * @remarks
 * You can identify this variant by checking for `subtype: "voice"`.
 *
 * The same file could be uploaded as either a voice block, or as an {@link AudioBlock}.
 * The same data will be available either way, but they will be rendered differently in the UI.
 *
 * Includes metadata about the duration of the recording in seconds, where available.
 *
 * Voice recordings done in the TalkJS UI will always include the duration.
 * Voice recording that you upload with the REST API or {@link Session.uploadVoice} will include this metadata if you specified it when uploading.
 *
 * Voice recordings will never be taken from a reply to an email notification.
 * Any attached audio file will become an {@link AudioBlock} instead of a voice block.
 *
 * @public
 */
export declare interface VoiceBlock {
    type: "file";
    subtype: "voice";
    /**
     * An encoded identifier for this file. Use in {@link SendFileBlock} to send this voice recording in another message.
     */
    fileToken: FileToken;
    /**
     * The URL where you can fetch the file
     */
    url: string;
    /**
     * The size of the file in bytes
     */
    size: number;
    /**
     * The name of the file, including file extension
     */
    filename: string;
    /**
     * The duration of the voice recording in seconds, if known
     */
    duration?: number;
}

export declare interface VoiceRecordingFileMetadata {
    /**
     * The name of the file including extension.
     */
    filename: string;
    /**
     * The duration of the recording in seconds, if known.
     */
    duration?: number;
}

export { }
